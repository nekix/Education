## Глава 1. Начало работы с ASP.NET Core
Варианты использования:
1. Минимальные API (для мелочи);
2. web-api (классика)
3. gRPC API (для внутренних сервисов);
4. MVC (классика);
5. Razor Pages (отрисовка на стороне сервера, модная замена MVC);
6. Blazor WebAssembly.
Выполнение на клиенте (WebAssembly, WASM), в т.ч. автономно; UI на C# в браузере.
7. Blazor Server
Выполнение на сервере, WebSockets для взаимодействия.
8. Blazor гибрид (предыдущих двух режимов);
9. API с классическим фронтом Angular, React, Vue.

К сожалению (легко скрыть бардак) построен вокруг DI, стараюсь по возможности для контроллеров и их зависимостей уходить от этого и собирать их явно.

Основные принципы работы:
1. Конвеер;
2. Kestrel или аналог.
3. HttpContext;

### Задания

1. Подумай, какие бы шаблоны проектов ты бы выбрал для каких задач.

    **Решение:**
    
    1. minimap-api - для простых внутренних сервисов;
	2. web-api, api с фронтом на Angular, React, Vue - всегда, когда не нужен UI, илю UI отдельно в напр. Angular, React проектах;
	3. gRPC API - с ним не работал, так что на данный момент только если этот протокол уже будет устоявшимся в системе, с которой мне нужно будет работать;
	4. MVC, Razor pages - когда есть UI. MVC в сравнении с Razor pages для себя разницы особой не вижу, выбирал бы MVC, если бы большая часть команды уже с ним работала, в иных случаях Razor pages, они показались более быстрыми для разработки.
	5. Blazor WebAssembly, Blazor Server, Blazor гибрид - если бы предоставили выбор и время на изучение, то попробовал сделать проект на нем. Заманчиво звучит большая независимость от HTML, CSS, JS, да и сам WASM. Но с другой стороны, когда я их пробовал, для них было малова-то хороших библиотек компонентов, по сравнению с классическим JS, TYPESCRIPT.

2. Создай приложение для будущих заданий по минимальному шаблону ASP.NET Core. Отключи все предлагаемые галочки.
	
	**Решение:**
	
	Проект создан и доступен по ссылке: `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore`

## Глава 2. Что такое ASP.NET Core
Зачем нужна платформа ASP.NET Core в контексте веб разработки? Для динамики (изменений, поведений). Для статики хватит статического сайта.

Kestrel убрал жесткую зависимость от IIS.
Можно использовать аналоги Kestrel (IIS in process, HTTP.sys), можно (и чаще всего) используется вместе с обратным прокси сервером (nginx, IIS).

### Задания
1. Вспомнить, с какими схемами работал (IIS, nginx, Kestrel).

	**Решение:**
	
	Работал изначально с Kestrel, который используется автоматически в Visual Studio, а при развертывании в производственной среде использовал IIS, In-process hosting. Тогда ещё не особо понимал, чем отличается In-process от Out-of-process модели. Сейчас работаю в Kubernetes, где обратный прокси nginx. Не до конца пока понимаю весь конвеер работы, но постепенно разбираюсь.

2. Изучите шаблон `Strangler Fig` и его применимость в контексте ASP.NET Core.

	**Решение:**
	
	Шаблон применяется для модернизации устаревших систем. Суть метода в том, чтобы в целях модернизации мы не меняли существующие проекты, а создали новый, в который заложили бы (архитектурно) почву для нужных нам изменений. Новый функционал добавляли в новый проект, старый функционал постепенно тоже переносили в него. Если требуется выполнение старого неперенесенного функционала, то его исполнение адресуется старому проекту, если нового или уже перенесенного, то новому. В контексте ASP.NET Core это связано с предлагаемым Microsoft подходом к миграции с ASP.NET Framework на ASP.NET Core `https://learn.microsoft.com/en-us/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`. Подход описывается как хорошо работающий для старых монолитов или систем тип "Черный ящик", функционал которых менять опасно. Основное что необходимости здесь в целом, так это проксирование трафика через новое приложение. При необходимости можем переключиться/откатиться на старый функционал (мы его не меняли). Интересная для меня статья по теме `https://habr.com/ru/companies/kuper/articles/849730/`. А здесь предлагается пример небольшой реализации паттерна на ASP.NET Core `https://code-maze.com/csharp-strangler-fig-architectural-pattern/`.

3. Изучите `Yarp`. Опробуйте его как прокси-сервер для вашего приложения. Имулируйте в двух проектах (или в одном через разные наборы эндпоинтов), что вы переходите с легаси кода на новый. Вам нужно сделать приложение, через которое будут проходить все запросы, и оно либо будет само обрабатывать ответ, либо перенаправлять на 'legacy' проект через `Yarp`.
    
	Ссылки для справки:

	* `https://learn.microsoft.com/ru-ru/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`
	* `https://dotnet.github.io/yarp/`
	
	
	**Решение:**
    
    Выполнил задание, заодно поигрался с маршрутизацией, на практике вспомнил, что `WebApplication.Run` является терминальным middleware, а не endpoint. А это значит, что он выполниться раньше любого определенного endpoint (если только нет хитрого разветвления через `Map()`). Проксирование сработало, раньше этой библиотеки не видел, буду иметь ввиду если нужно будет что-то такое лёгкое быстро реализовать. Из близких аналогов есть ещё `Ocelot`. 
    
    Хорошая презентация: `https://dotnext.ru/archive/2024/talks/5c9277abd9954b36b91671a9fcfa1f38/`.
	
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%202/Exercise%203/AppBuilder.cs`
    
	

## Глава 3. Наше первое приложение
Kestrel получая низкоуровневый запрос преобразует его в `HttpContext`. Этот `HttpContext` дальше путешествует по конвееру и обратно уже с готовым ответом. Ответ передается Kestrel и отдается наружу (на обратный прокси/сервер и т.д.)

Для командной строки:
* Создать решение: `dotnet new sln -n WebApplication1`
* Создать проект (`--use-program-main` для явной функции `Main`): `dotnet new web -o WebApplication1`
* Добавить проект в решение: `dotnet sln add WebApplication1`

Внутри проекта:
Восстановить зависимости: `dotnet restore`;
Сборка (неяно запускает `dotnet restore`, чтобы скипнуть `--no-restore`): `dotnet build`;
Запуск (неявно запускает `dotnet restore`, `dotnet build`, чтобы скипнуть `--no-restore --bo-build`): `dotnet run`.
Добавить nuget пакет: `dotnet add package <packagename>`

> ### Альтернативы CreateBuilder
> Надо опробовать в действии: `CreateSlimBuilder` и `CreateEmptyBuilder`.
> 
> **`CreateEmptyBuilder`** звучит интересно, но он совсем не документирован, тяжело найти информацию о том, как настроить его с нуля не зная внутренностей WebApplicationBuilder. С другой стороны побуждает выяснять, как оно работает изнутри) 
> 
> В любом случае настроил базовый мини пример запуска чисто для прослушки одного порта. 
>
> **`CreateSlimBuilder`** больше документации, скорее всего его может хватить для многих приложений, позволяет урезать лишние модули. 
>
> **Меньше лишних модулей -> меньше сложностей настроек -> проще разработка.**
> https://andrewlock.net/exploring-the-dotnet-8-preview-comparing-createbuilder-to-the-new-createslimbuilder-method/
> https://sd.blackball.lv/en/articles/read/19465-a-dive-into-net-8-native-aot-and-efficient-web-development
> https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
>
> **`CreateBuilder`** автоматически добавляет маршрутизацию (RoutingMiddleware), EnpointMiddleware, компонент обработки ошибок в окружении разработки и другое.
>
> Для тестов по ходу изучения книги будет полезно: https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host
>
> Также в главе 30 настройка приложения через универсальный IHost с большим контролем, нежели WebApplication.

Далее по ходу главы нам напоминают про конвеер, важность его порядка, DI, IOC.

### Задания

1. Создать приложение, которое пробует разные способы настройки приложения (**`CreateEmptyBuilder`**, **`CreateSlimBuilder`**, **`CreateBuilder`**). Собрать и запустить приложение консольными командами. Попробуйте захостить их одновременно)

	**Решение:**
    Выполнил задание. Настройки для минимального примера `CreateSlimBuilder` и `CreateBuilder` не отличались, по умолчанию все само выставляется. А вот для `CreateEmptyBuilder` пришлось немножко помучиться, чтобы выудить из документации что под капотом обычно вызывается у `CreateBuilder` например и что нужно для запуска минимального примера с прослушкой одного порта.
    
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%203/Exercise%201/AppBuilder.cs`
    

## Глава 4. Обработка ошибок с помощью конвейера промежуточного ПО
> Ох, создание своих middleware расмматривается только в 31 главе...

Middleware может:
* при перехвате входящего запроса:
    * обработать его и вернуть ответ; 
    * обработать его и направить дальшей по конвееру;
* при перехвате исходящего ответа:
    * обработать его и направить дальше по конвееру;
    * обработать его и направить сразу на веб-сервер ASP.NET Core.

> ### Run, Use, Map
> * `IApplicationBuilder.Run()` - терминальный компонент (завершающий запрос)
> * `IApplicationBuilder.Use()` - создает middleware, который позволяет (но не обызывает) передать обработку запроса следующим в конвеере компонентам.
>    * `UseWhen()` - ответвление конвеера по условию. Отличие от MapWhen() в том, что может вернуть управление в основную ветвь если не содержит промежуточный терминальный уровень. (т.е. вошло в `UseWhen`, выполнилось, вызвало внутри `await Next()` и двигается дальше от вызова `UseWhen` по конвееру).
> * `IApplicationBuilder.Map()` - позволяет резветвить конвейер на основе пути запроса. Может включать подветви (другие map).
>    * `MapWhen()` - ответвление конвеера по условию (вместо просто пути).

**ASP.NET Core автоматически добавляет "фиктивный" компонент `EndpointMiddleware` в конец конвеера, который при вызове всегда возвращает ответ с ошибкой 404 (`CreateBuilder`, `CreateSlimBuilder`). Также добавляется компонент страницы исключений разработчика `app.UseDeveloperExceptionPage()` в окружении разработки (`app.Environment.IsDevelopment`).**
> Вот как оно оказывается работает.

**Коды ошибок:**
* **1xx** - информационные. Общее подтверждение.
* **2xx** - успешно.
* **3xx** - перенаправление.
* **4xx** - ошибка клиента.
* **5xx** - ошибка сервера.

**Добавляют** компоненты в конвеер методы `Use*()`. Такова конвенция. А метод `app.MapGet("/", () => "Hello World!");` **определяет конечную точку**, которая используется компонентом маршрутизации `app.UseRouting();` (т.е. не добавляет новый компонент, middleware).

Ручное включение уже определенных аватоматически компонентов позволяет изменить их порядок (он встанет там, где вы его определелили).

Для обработки исключений в промышленном окружении можно использовать `ExceptionHandlerMiddleware`. Простой способ добавления: `app.UseExceptionHandler("/error")`. Указывается путь к старнице с ошибки. Middleware вызовет этот путь после перехвата исключения для генерации конечного ответа.

Как работает:
1. Какой-нибудь middleware выбрасывает исключение;
2. `ExceptionHandlerMiddleware` перехватывает исключение;
3. Удаляет любой определенный к этому моменту **частичный** ответ пользователю.
4. Перезаписывает путь запроса на `path`, на который указаывает `app.UseExceptionHandler("path")`;
5. Отправляет запрос обратно по конвееру так, будто он был изначально направлен по пути `path`;
6. Конвеер генерирует новый ответ как обычно;
7. Когда ответ снова возвращается в `ExceptionHandlerMiddleware`, он изменяет `StatusCode` ответа на `500` и продолжает передачу ответа по конвееру на веб-сервер.

Если ошибка произойдет после повторного отправления запроса по конвееру и он снова вернётся в `ExceptionHandlerMiddleware`, то он позволит исключению дойти до самого верха конвеера. Сервер вернёт клиенту низкоуровневую ошибку с `StatusCode` ответа `500`.

Альтернативный подход для обработки ошибок представлен по ссылке `https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`.

Последующие middleware после `ExceptionHandlerMiddleware` будут считать повторное выполнение как новый запрос, а предыдущие не узнают, что произошло что-то необычное.

> **Важный нюанс!** Middleware может изменять ответ, сгенерированный компонентами далее по конвееру только если ответ не был отправлен клиенту. Например, если возникла ошибка, когда отправляется статический файл клиенту, может начаться немедленная потоковая передача байтов клиенту (из соображений производительности). В этом случае компонент обработки ошибок не сможет запуститься, т.к. он не может сбросить ответ. С этим мало что можно сделать.

**WebApplication** автоматом добавляет (по необходимости) следующие компоненты:
1. `HostFilteringMiddleware`. Безопасность. Ограничивает хосты, по которым можно обращаться к приложению. Защищает от нескольких типов атак. Было бы интересно попробовать воспроизвести эти типы атак. Можно больше почитать по `https://andrewlock.net/adding-host-filtering-to-kestrel-in-aspnetcore/`

2. `HostFilteringMiddleware`. Управляет обработкой пересылаемых заголовков. Подробнее будет изучено в главе 27.

3. `DeveloperExceptionMiddleware`. В окружении разработки (`app.Environment.IsDevelopment`) добавляется при запуске приложения. Выводит детальную информацию об возникшем ислючении.

4. `RoutingMiddleware`. Если добавляются конечные точки в приложение, то вызывается метод `UseRouting`, причём до добавления в приложение какого-либо собственного (добавленного разработчиком) компонента.

5. `AuthenticationMiddleware`. Если настраивается аутентификация, то этот компонент аутентифицирует пользователя. Рассматривается в главе 23.

6. `AuthorizationMiddleware`. Запускается после аутентификации. Определяет разрешения пользователя на выполнения ednpoint-а. Если нет прав, то запрос прерывается. Подробнее в главе 24.

7. `EndpointMiddleware`. Соединятся с `RouttingMiddleware` для выполнения конечной точки. Добавляется в конвеере в конец, после любых других компонентов, которые настраиваются в `Program.cs`.

> Но в зависимости от конфигурации `WebApplication` может не создавать эти компоненты + можно переопределить их порядок если самому объявить их.

### Задания
1. Изучить статью. Попробовать повторить подходы в ней (стандартный и через отдельный middleware) комбинируя их так, чтобы исключение в любом случае было обработано.
`https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`

	**Решение:**
    Выполнил задание. Все заработало так, как и ожидалось. По пути немного поизучал и поработал с более низкоуровневым `HttpContext`, обнаружил полезный сервис для формирования ответов с ошибками `IProblemDetailsService`, до этого напрямую его не использовал.
    
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%203/Exercise%201/AppBuilder.cs`

## Глава 5. Создание JSON API с помощью минимальных API

> Для изучения Blazor рекомендутеся книга "Blazor in action" Криса Сейнта.

HTTP API, JSON API, REST API.

gRPC, GraphQL.
> * Для изучения gRPC рекомендуется `https://docs.microsoft.com/aspnet/core/grpc`.
> * Для изучения GraphQL рекомендуется книга "Создание веб-API с помощью ASP.NET Core" Валерио Де Санктис.

**Параметризированные маршруты**

`app.MapGet("person/{name}", (string name) => ...);`

По умолчанию ответ десериализуется в JSON.

* GET - `MapGet(path, handler)`. Только получение данных. Можно кешировать.
* POST - `MapPost(path, handler)`. Создание нового ресурса.
* PUT - `MapPut(path, handler)`. Создание или замена существующего ресурса.
* DELETE - `MapDelete(path, handler)`. Удаление данного ресурса.
* PATCH - `MapPatch(path, handler)`. Изменение данного ресурса.
* Несколько методов - `MapMethods(path, methods, handler)`. Несколько операций.
* Все методы - `Map(path, handler)`. Несколько операций.
* Все методы - `MapFollback(handler)`. Для резервных маршрутов. Вызывается при отсутсвии совпадений по другим конечным точкам. Подробнее `https://weblog.west-wind.com/posts/2020/Jul/12/Handling-SPA-Fallback-Paths-in-a-Generic-ASPNET-Core-Server`.

Если определена например только `app.MapGet("person/{name}, string name => ...);`, а мы стучимся POST методом, то обработчик не запуститься, а вернётся `405 Method Not Allowed`.

Если определена конечная точка напр. `app.MapPost("person/{id}", AddPerson);` и `void AddPerson(int id, Person person)`, то `person` будет создан из десериализованного JSON-объекта из `Body` запроса, что работает для сложных типов (их невозможно извлечь из URL запроса). **В minimal-api данные могут быть привязаны к телу запроса только в формате JSON.**

**Возврат ошибок и статус кодов**

В minimal-api можно возвращать результат операции в `IResult`. Например для возврата статус кодов и ошибок. Для этого используются `Results` и `TypedResults`. Второй проще использовать в модульных тестах за счёт того, что он возвращает не `IResult`, а более конкретный обобщенный тип, например `Ok<T>`.

Сводка статус кодов и их предполагаемого использования для справки: `https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status`

При необходимости большего контроля над ответом можно использовать объект `HttpResponse` в перегрузке по типу `app.MapGet("/path", (HttpResponse response) => { ... });`

**Problem details**

Для возврата ошибок клиентам желательно использовать веб-спецификацию **Problem Details**. Это позволяет предоставлять машиночитаемые ошибки для HTTP API. `https://www.rfc-editor.org/rfc/rfc7807.html`

Для этого можно использовать методы `Results.Problem()`, `Results.ValidationProblem()` и `TypedResults`. Первые два возвращают `ProblemHttpResult`.

**Приведение всех возвращаемых ошибок к Problem Details**

Два класса ошибок, которые обрабатываются по разному:

1. Исключения
2. Ответы с кодом состояния ошибки

Исключения можно обработать с помощью `ExceptionHandlerMiddleware`. Вместо создания отдельной конечной точки для обработки предпочтительнее использование сервиса `IProblemDetailsService`. Его можно добавить так: `builder.Services.AddProblemDetails()`. Если он добавлен и `ExceptionHandlerMiddleware` используется перегрузка без аргументов (без пути к обработчику ошибок), то он автоматически использует зарегистрированный `IProblemDetailsService` для генерации ответа. `DeveloperExceptionPageMiddleware` также поддерживает `IProblemDetailsService` и использует его, если в запросе указано, что он не поддерживает HTTP.

Коды состояния ошибок можно либо на всех конечных точках обеспечить возврат `Problem Details`, либо (не обязательно вместо) добавить `StatusCodePagesMiddleware`. Если через него будет возвращаться ответ с кодом состояния ошибки но без тела ответа, то middleware автоматически добавит `Problem Details` в тело ответа.

> `StatusCodePagesMiddleware` можно также использоваться для повторого выполнения конвеера как в случае с `ExceptionHandlerMiddleware`, но уже в зависимости от кода состояни ошибки перенаправлять на разные enpoint-ы.

**`Result` доп.методы**

* `Results.File()` - возврат файла;
* `Results.Byte()` - возврат двоичных данных;
* `Result.Stream()` - возврат данных асинхронно, через поток.

Для `File` и `Byte` доступен `EnableRangeProcessing` для запроса и передачи диапозона данных. `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests`

**Фильтры конечных точек**

Позволяют вынести отдельно код, который будет выполняться до или после конечной точки. Каждый фильтр привязан к свой конечной точке и срабатаывает только если запрос достиг её. Могут также замкнуть конвеер. Можно добавлять несколько фильтров на одну конечную точку, выполняются аналогично middleware, но только "вокруг" своей конечной точки.

Пример `app.MapGet(...).AddEndpointFilter(...).AddEndpointFilter(...)...;`

Внутри через можно получить аргументы endpoint-а: `context.GetArgument<T>()`.

**Фильтры затрудняют понимание потока приложения, лучше использовать только если в нескольких конечных точках обнаружился одинаковый код и его вынос в фильтры вместо вызова в отдельной функции внутри конечной точки сильно упрощает понимание кода.**

Отличие от middleware:

* Выполняется только для запрос, которые достигли связанный ednpoing;
* Имеют доступ к доп. сведениям о конечной точке, например к возвращаемому значению `IResult`;
* Фильтры действуют более точечно, middleware наоборот ко всем запросам.

**Фабрики фильтров**

Специфичная вещь, позволяет создавать обобщенные фильтры конечных точек, у которых снижена зависимость от реализации endpoint-ов (например от порядка аргументов).

`AddEndpointFactory`

**`IEndpointFactory`**

Аналог определению через лямбда-выражения `AddEndpointFilter`.

**Группы маршрутов**

Используются для извлечения общих сегментов пути или фильтров в одно место.

`app.MapGroup("/groupPath");` => `RouteGroupBuilder`. Для каждого `RouteGroupBuilder` можно вызывать свои `Map` методы, которые сработают только внутри группы. Также и фильтры, вложенные группы.

### Задания
1) Изучить разницу между HTTP API, JSON API, REST API.

    **Решение**
    HTTP API является общим для оставшихся двух понятий. HTTP является протоколом, соответсвенно HTTP API, это API, использующий HTTP для взаимодействия. JSON API в таком случае является соглашением/спецификацией на формат данных для взаимодействия по протоколу HTTP посредством документов формата JSON. REST API же архитектурный стиль, который декларирует способ взаимодействия с сервером, а не формат данных для взаимодействия. REST API и JSON API могут комбинироваться.

2) Реализовать с помощью минимального API и изученных в главе инструментов api для операций read со списком фруктов и овощей. Логируйте эти операции на верхнем уровне (объеденив их в группы). Ошибки должны возвращаться в соответствии с `Problem Details`.
    
    **Решение**
    Реализовал по ссылке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%205/Exercise%202/AppBuilder.cs`. В рамках реализации сделал одну группу для логирования операций к данным конечным точкам, а в них настроил возврат результата через `TypedResults` и `Results`.

## Глава 6. Сопоставление URL-адресов с конечными точками с помощью маршрутизации

Машрутизация - сопоставление входящего запроса с методом, который будет его обрабатывать.

За маршрутизацию ответсвенен компонент маршрутизации.

**Строка запроса не используется системой маршрутизации для определения обработчика**

Руководство Google по SEO для начинающих (чтобы правильно закодировать иерархию сайта): `https://developers.google.com/search/docs/fundamentals/seo-starter-guide?visit_id=638804892081427264-2671799893&rd=1&hl=ru`

Как вариант ещё может использоваться маршрутизация на основе физического расположения обработчика на жестком диске (простота). Razor pages используют оба подхода.

Маршрутизация в ASP.NET Core реализуется с помощью двух компонентов:

* `EnpointRoutingMiddleware` - выбирает конечные точки для обработки запроса;

* `EndpointMiddleware` - вызывает конечную точку выбранную `EnpointRoutingMiddleware`.

Каждая конечная точка (создается вызовом `Map()` на `IEndpointRouteBuilder`, в т.ч. `WebApplication`) связана с **шаблоном маршрута** (шаблоны URL-адреса).

**`RoutingMiddleware` прикрепляет выбранную конечную точку к `HttpContext`.

**Синтаксис шаблона маршрута**

Маршрут разбивается на сегменты, которые обычно отделяются `/`. Можно использовать и другой разделитель (сложный сегмент), но это не рекомендуется из-за их особенностей (`https://learn.microsoft.com/ru-ru/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#complex-segments`).

Каждый сегмент либо литеральный (`product\`), либо параметр (`{id}`). Литеральные сегменты не чувствительны к регистру.

Значения параметров фиксируются и их можно получить в обработчике конечной точки.

* {id} - обязательный сегмент;

* {name=all} - необязательный сегмент со значением по умолчанию;

* {filter?} - просто необязательный сегмент;

**Необязательные параметры можно поставить только в конец шаблона. Все параметры до них (в т.ч. другие необязательные) должны быть заданы (прим. `/product/{category}/{name=all}/{id?})`, до `id` должны быть определены `name` и `all`**

Можно наложить ограничения на маршрут (больше информации на `https://learn.microsoft.com/ru-ru/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#route-constraints`):

* `{qty:int}`, `{id:guid}`, `{age:min(18)}`, `{qty:int?}`, `{qty:int:max(10)}` и т.д.

**Не используйте ограничения маршрута для проверки общих вводимых данных. Это приведет к ошибке NotFound для пользователя, что введёт его в заблуждение.**

Вышеприведенные параметры не были жадными (захватывали минимум для себя).

Также есть универсальные параметры, которые являются жадными (с одной или двумя `*`) и захватывают всё. Для входящих запрос ведут себя одинаково. Различается поведение только при генерации URL-адресов.

Пример: `/{currency}/convert/{**others}`

Соответсвуют:

* `/USD/convert/GBP`

* `/USD/convert/GBP/EUR`

* `/USD/convert/GBP/EUR/CAD`

**Генерация URL-адресов из параметров маршрута**

Универсальные жадные параметры с одной звёздочкой экранирует косую черту, а с двумя звёздочками не экранирует. Обычно используется версия с двумя звёздочками.

В минимальных API можно использовать `LinkGenerator`.

Пример:

`app.MapGet("/product/{name}", ...).WithName("product");`

`app.MapGet("/links", (LinkGenerator links => link.GetPathByName("product", new { name = "big-widget" }))`

`WithName()` добавил метаданные к конечной точке. Имена конечных точек чувствительны к регистру и должны быть уникальны.

`LinkGenerator.GetUriByName` для генерации полного пути. Хост для метода обычно берут из `HttpContext`. Если нет ограничений по `allowedHost`, то возможны уязвимости.

`LinkGenerator` автоматически по названию параметров маршрута понимает, куда их нужно подставить.

Также можно использовать `app.Map("...", () => Results.RedirectToRoute("endpoint_name"));`. По умолчанию генерирует `StatusCode 302 Found` и включает сгенерированный адресс в заголовок ответа `Location`. Может привести к такому поведению (`302`), что браузер будет сразу перенаправлять новые запросы на этот адрес, даже не загружая исходный. Следует быть осторожным. Соответсвующая статья: `https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status#redirection_messages`.

`Results.Redirect()` используется для перенаправления на заданный URL.

`WebApplication build.Services.Configure<RouteOptions>(o => ...)` для конфигурации генерации URL адресов (напр. чтобы были в нижнем регистре). При необходимости можно переоперделить при вызове конкретного метода генерации.

### Задания

1. Создать небольшое приложения "конвертации" валют. Пусть основная конечная точка будут как в примере из книги для универсальных параметров конечной точки курсов валют. Но при этом добавь ещё одну точку для просмотра курсов валют по пути `{from}/rate/{to}`, но при этом они должны перенаправляться на `http://sberbank.ru/ru/quotes/currencies?tab=sbol&currency={currency}&currency={newCurrency}`.

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%206/Exercise%201/AppBuilder.cs`. В процессе чтения и реализации ещё раз напомнил себе систему маршрутизации ASP.NET Core.

## Глава 7. Привязка модели и валидация в минимальных API.

**Привязка модели - механизм извлекающий значения из запроса и использующий их для создания объекта .NET. Затем он передает эти объекты в метод обработчик конечной точки**.

Выполняется односторонняя привязка.

`EndpointMiddleware` выполняет преобразование строк параметров в объекты модели.

Минимальные api могут использовать следующие источники привязки для аргументов:

* значения маршрута (сегменты и значения параметров по умолчанию)

* значения строки запроса

* значения заголовков

* тело JSON

* сервисы внедрения зависимостей

* собственная привязка через HttpRequest

**В minimal-api не работает автоматическая привязка к `application/x-www-form-urlencoded`, только тело запроса JSON. Но можно получить доступ через `HttpRequest.Form`.

Сначала пытается привязать параметр к параметру, указанному в шаблоне маршрута. Если не смог, то попытается найти нужный в строке запроса.

Аттрибуты на параметрах в методе обработки конечной точки `[FromRoute]`, `[RromQuery]`, `[FromHeader]`, `[FromBody]`, `[FromServices]` явно указывают, откуда взять значения параметров. Первые три из них позволяют выполнить привязку к простым типам (`int`, `double`).

**Простой тип - тип, реализующий TryParse метод. Можно реализовать свой простой тип (IParsable, либо статические методы TryParse с подходящей сигнатурой).

**Если попытаться связать несовместимые типы, то ASP.NET Core выдаст исключение BadHttpRequestException и вернёт ответ 404 Bad Request.

Для minimal-api нельзя заменить библиотеку сериализации `System.Text.Json` (при привязках к телу запроса или записи в тело ответа), можно только настроить некоторые параметры.

Если формат тела запроса отличается от JSON, то обработчик конечной точки не запуститься, а `EndpointMiddleware` вернет ответ `415 Unsopported Media Type`.

Если попытаться привзять тело HTTP-метода, у которого обычно нет тела (`GET`, `HEAD`, `OPTIONS`, `DELETE`, `TRACE`, `CONNECT`), то получите исключение `InvalidOperationException` во время выполнения. Можно обойти это ограничение, используя на параметре атрибут `[FromBody]`, но не рекомендуется это делать, т.к. это поведение не соотвествует `RFC9110`.

**Можно привязать массив к параметру метода (или к `[FromRoute]`), например из строки запроса.** Напр. `products?id=123&id=456`. `app.MapGet("/products", ([FromQuery]int[] id ) => {...});`. Подходят любые простые типы, `string[]` и `StringValues`.  ASP.NET Core автоматом (без аттрибута) привязывает массив к строке запроса если запрос `GET`. `HEAD` или `DELETE` и массив представляет собой массивы простых типов. В ином случае пытается привязать к телу.

Все параметры по умолчанию обязательные.

Если `app.MapGet("/products/{id?}", (int  id) => {...});` и отправить запрос по `/products`, то это вызовет ошибку `BadHttpRequestException` и вернёт `400 Bad Request`. Можно избежать отметить параметр допускающим `null` (`int? id`). Аналогично для сложных типов.

В минимальных API можно получить доступ из обработчика (передав в качестве параметров) также следующие типы:

* `HttpContext` - все сведения и о запросе, и об ответе;

* `HttpRequest` - эквивалент `HttpContext.Request`;

* `HttpResponse` - эвивалент `HttpContext.Response`;

* `CancellationToken` - эквивалент `HttpContext.RequestAborted`. Токен срабатывает, если клиент прерывает запрос (полезно для задач с длительным временем выполнения). Подробнее `https://andrewlock.net/using-cancellationtokens-in-asp-net-core-minimal-apis/`;

* `ClaimsPrincipal` - эквивалент `HttpContext.User`. Содержит данные аутентифкации пользователя;

* `Stream` - эквивалент `HttpRequest.Body`. Полезен, когда необходимо обрабатывать большие объёмы данных из запроса, не удерживая их все в памяти одновременно;

* `PipeReader` - эквивалент `HttpContext.BodyReader`. Полее высокоуровневый API по сравнению с `Stream`, полезен в аналогинчых ситуациях. Пространство имен `System.IO.Pipelines`.  Подробнее `https://learn.microsoft.com/ru-ru/dotnet/standard/io/pipelines`;

* Зарегистрированные в контейнере `DI` сервисы. Можно принудительно пометить атрибутом `[FromServices]` (например при использовании своего контейнера `DI`).

**Загрузка файлов**

> **Загрузка файлов потенциально опасное действие. Не стоит доверять указанному имени файла, нужно быть осторожным с загружаемыми большими файлами и не позволять файлам выполняться на сервере. Также вопрос где и как хранить файлы (БД, файловая система, S3 и т.д.). Лучше избегать загрузки файлов пользователями без крайней необходимости, а к самими загружаемым файлам относится с осторожностью как к потенциальному вредоносу.**

Загрузка файлов выполняется через интерфейсы `IFormFile` и `IFormFileCollection`.

> Эти интерфейсы могут предоставлять свойство `string FileName`. **Никогда не стоит использовать предоставленное имя файла в коде. Это может привести к атаке на веб приложение и доступа к файлам, к которым пользователям не следует иметь доступ. Всегда создавайте новое имя для файла, прежде чем сохранять его где-либо!**

Данные интерфейсы подходят для небольших файлов, т.к. всё содержимое файла буферизируется в памяти и на диске перед его получением. Для больших файлов следует использовать потоковую передачу данных `https://learn.microsoft.com/ru-ru/aspnet/core/mvc/models/file-uploads?view=aspnetcore-9.0#upload-large-files-with-streaming`.

**Привзяки модели**

Для своей кастомной логики привязки модели можно реализовать статический интерфейс `IBindableFromHttpContext` или статический методы `public static ValueTask<T?> BindAsync(HttpContext context)` или `public static ValueTask<T?> BindAsync(HttpContext context, ParameterInfo parameter)`. Если не спарсить данные, то стоит вернуть `null`.

Порядок выбора источника привязки в minimal-api к параметру:

1. Через атрибут `[From*]`;

2. Если тип парпаметра общеизвестный тип, напр. `HttpContext`, `HttpRequest`, `Stream`, `IFormFile`;

3. Если тип параметра имеет метод `BindAsync`;

4. Если строка или имеет `TryParse()`:
    a. к параметру маршрута если совпадает с именем параметра в маршруте;
    b. к строке запроса.

5. Если параметр массив простых типов, массив строк или `StringValues`, а сам запрос представляет метод, который обычно не имеет тела (напр. `Get`).

6. Если есть в `DI`, то из `DI`.

7. Привязка к телу десериализацией из JSON.

**Для упрощения модели привязки (куча параметров метода обработчика, атрибуты) можно использовать атрибут `[AsParameters]`, который указывает, что аргументы и параметры объеденины в один отдельный класс.**

**Обработка пользовательского ввода путем валидации модели**

В минимальном api не включаются отдельные механизмы валидации, используются обычно фильтры для реализации валидации и/или с атрибутами валидации (`DataAnnotations`), интерфейсами `IValidatableObject`. Об атрибутах валидации подробнее в: `https://learn.microsoft.com/ru-ru/dotnet/api/system.componentmodel.dataannotations?view=net-9.0`.

Можно использовать аналоги для валидации по типу `FluentValidation`.

Можно написать собственный фильтр для обработки валидации, а можно использовать `NuGet` пакет `MinimalApis.Extensions` и метод расширения `WithParameterValidation()`.

### Задания

1. Создать API для поиска товаров с основным поисковым запросом (строка текста с тем, что пользовательн хочет найти), категория (из маршрута), фильтры по цене, доступном кол-ве, тегам. Входные данные должны валидироваться, должны поддерживать множественные указания тегов. 

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%207/Exercise%201/AppBuilder.cs`. В процессе реализации задания обнаружил, что если передать 3 разных параметра `min-price` в строке запроса, то приложение генерирует `OverflowException`. Что-то странное происходит под капотом у ASP.NET Core. Поставлю в задания `Планы на потом` выяснить, чем вызвано это поведение (возможно из-за внешней библиотеки, подключающей валидацию к конечной точке).

### Задания

Глава слишком обзорная для заданий.

## Глава 8. Введение во внедрение зависимостей

> В ASP.NET Core встроено внедение зависимостей и полностью уйти от него сложно (но частично можно).

Граф зависимостей - набор объектов, которые нужно создать для получения определенного запрашиваемого "корневого" объекта.

Основная задумка - перемещение графа зависимостей объекта в его конструктор (или фабричный метод) и делегация их инициализации в сервис "контейнер внедрения зависимостей". Сами зависимости желательно передавать интерфейсами.

Преимущество - снижаем зависимость и связность объекта с используемыми им зависимосятми.

Минус (именно контейнера) - легко случайно скрыть бардак в графе зависимостей, а разрешаться это все будет только в рантайме = теряем преимущества статической типизации.

`RequestDelegateFactory` запрашивает экземеляры объектов для разрешения зависимостей у контейнера (для mininmal API).

В Razor Pages используются активаторы модели страницы, котоорые вызывают контейнер внедрения зависимостей.

### Задания

Глава слишком обзорная для заданий.

## Глава 9. Регистрация сервисов с помощью внедрения зависимостей

Базовый DI контейнер ASP.NET Core использует некую оптимизированную рефлексию.2

Для регистрации `WebApplicationBuilder.Services.Add...`.

Для получения из контейнера вручную используются `WebApplicationBuilder.Services.GetService<T>()ж и .GetRequiredService<T>();` (паттерн Локатор сервисов).

Для регистрации открытых обобщенных типов используется конструкция такого вида: `services.AddScoped(typeof(IRepository<>), typeof(DbRepository<>));`.

Если зарегистрировано несколько реализаций для одного интерфейса и объект вызывает только один интерфейс (не `IEnumerable`), то внедряется последний зарегистрированный в DI (так можно например заменять уже зарегистрированные сервисы).

Для регистрации если для данного сервиса ещё нет реализаций можно использовать `buider.Services.TryAdd...` методы.

Для замены уже зарегистрированных обработчиков сервиса можно использовать `builder.Services.Replace(new ServiceDescriptor(typeof(IMessageSender), typeof(SmsSender), ServiceLifetime.Scoped));`. Жизенный цикл должен быть указан тот-же, что уже использовался.

Жизненый цикл типа в DI контейнере ASP.NET Core:

* Transient - создает новый экземпляр сервиса при каждом его запросе;

* Scoped - в пределах **области применения** все запросы сервиса будут предоставлять один тот-же объект. Для разных - разные. В ASP.NET Core каждый запрос получает свою область применения;

* Singleton - всегда один и тот же экземпляр. **Все такие сервисы должны быть потокобезопасны!**

Если сервис реализует IDisposable, то DI контейнер при Transient, Scoped автоматически освобождает ресурсы когда область действия заканчивается.

**ЛОВУШКА**. Если зарегистрировать два сервиса напр. `DataContext` и `Repository`. При этом `Repository` требует для создания себя `DataContext`. И при этом `DataContext`scoped, а `Repository` singleton. Это всё создатс захваченную зависимость, при которой у нас всегда будет один `DataContext`, т.к. он внедряется в singleton (и соотвественно не высвобождается и не заменяется).

**Сервис должен использовать только те зависимости, жизненный цикл которых превышает или эквивалентен жизненному циклу сервиса.**

ASP.NET Core автоматически должен проверять в runtime такие проблемы и выбрасывать исключение. **По умолчанию такая проверка активируется только в окружении разработки (ValidateScopes, ValidateOnBuild).**

Проблемы, которые не может автоматом отловить контейнер DI и ASP.NET Core: `https://andrewlock.net/new-in-asp-net-core-3-service-provider-validation/`.

**Запрос сервисов scoped и transient напрямую из контейнера может привести к утечке памяти, посколько объекты остаются активными и не подвергаются сборке мусора до конца работы приложения.**

Создание свое области применения: `await (using var scope = app.Services.CreateAsyncScope()) {var service = scope.ServiceProvider.GetRequiredService<DataContext>() }`.


### Задания

1). Проверить, что будет, если зарегистрировать для одного и того-же сервиса реализации с разным жизненным циклом. То-же самое для `TryAdd...` и `Replace` методов. Изучить ValidateScopes, ValidateOnBuild поведения при данной ситуации.

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%209/Exercise%201/AppBuilder.cs`.
    В ходе экспериментов выяснил, что срабатывает последняя добавленная реализация сервиса НЕЗАВИСИМО от жизненного цикла предыдущей реализации. `Replace` добавляет новую реализацию с указанным `ServiceLifetime` если её не было ранее, и добавляет в конец списка реализация сервиса (т.е. она будет вызвана). `TryAdd` напротив, при попытке добавить с любым `ServiceLifetime`, если уже есть какая-либо (не важен `ServiceLifetime`) реализация не добавит (т.е. уже есть с `ServiceLifetime.Scoped`, пытаемся добавить новую с `ServiceLifetime.Singleton` и она не будет добавлена).

## Планы на потом.
1. Вернуться к `HostFilteringMiddleware` `https://andrewlock.net/adding-host-filtering-to-kestrel-in-aspnetcore/` и атакам, от которых он защищает. Хотелось бы опробовать воспоизвести эти атаки.

2) Ознакомиться с введением в HTTP от Firefox `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview`.

3) Пропустил введение интерфейсов IParsable. Изучить `https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/#static-abstracts-in-interfaces`.

4) Изучить что за новый для меня тип `StringValues` и зачем, где используется (глава 7).

5) Проблема нулевых ссылок, интересный материал (глава 7), ознакомиться: `https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/`.

6) Изучить и опробовать уязвимости, которые могут эксплуатировать злоумышленники при загрузке файлов через публичный API в приложение. Подробнее материал:  `https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload`.

7) Изучить и опробовать на практике уязвимости, которые закрывает валидация пользовательского ввода: `https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html`.

8) Глава 7. Задание 1. Выяснить, почему `OverflowException` возникает.

9) Глава 8. Статья про DI 2004 г. `https://www.martinfowler.com/articles/injection.html`. Также изучить разницу внедрения зависимостей и инверсии зависимостей (пост Дерика Бейли "Внедрение зависимостей НЕ тоже самое что и принцип инверсии зависимостей").