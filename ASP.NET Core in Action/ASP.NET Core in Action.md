## Глава 1. Начало работы с ASP.NET Core
Варианты использования:
1. Минимальные API (для мелочи);
2. web-api (классика)
3. gRPC API (для внутренних сервисов);
4. MVC (классика);
5. Razor Pages (отрисовка на стороне сервера, модная замена MVC);
6. Blazor WebAssembly.
Выполнение на клиенте (WebAssembly, WASM), в т.ч. автономно; UI на C# в браузере.
7. Blazor Server
Выполнение на сервере, WebSockets для взаимодействия.
8. Blazor гибрид (предыдущих двух режимов);
9. API с классическим фронтом Angular, React, Vue.

К сожалению (легко скрыть бардак) построен вокруг DI, стараюсь по возможности для контроллеров и их зависимостей уходить от этого и собирать их явно.

Основные принципы работы:
1. Конвеер;
2. Kestrel или аналог.
3. HttpContext;

### Задания

1. Подумай, какие бы шаблоны проектов ты бы выбрал для каких задач.

    **Решение:**
    
    1. minimap-api - для простых внутренних сервисов;
	2. web-api, api с фронтом на Angular, React, Vue - всегда, когда не нужен UI, илю UI отдельно в напр. Angular, React проектах;
	3. gRPC API - с ним не работал, так что на данный момент только если этот протокол уже будет устоявшимся в системе, с которой мне нужно будет работать;
	4. MVC, Razor pages - когда есть UI. MVC в сравнении с Razor pages для себя разницы особой не вижу, выбирал бы MVC, если бы большая часть команды уже с ним работала, в иных случаях Razor pages, они показались более быстрыми для разработки.
	5. Blazor WebAssembly, Blazor Server, Blazor гибрид - если бы предоставили выбор и время на изучение, то попробовал сделать проект на нем. Заманчиво звучит большая независимость от HTML, CSS, JS, да и сам WASM. Но с другой стороны, когда я их пробовал, для них было малова-то хороших библиотек компонентов, по сравнению с классическим JS, TYPESCRIPT.

2. Создай приложение для будущих заданий по минимальному шаблону ASP.NET Core. Отключи все предлагаемые галочки.
	
	**Решение:**
	
	Проект создан и доступен по ссылке: `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore`

## Глава 2. Что такое ASP.NET Core
Зачем нужна платформа ASP.NET Core в контексте веб разработки? Для динамики (изменений, поведений). Для статики хватит статического сайта.

Kestrel убрал жесткую зависимость от IIS.
Можно использовать аналоги Kestrel (IIS in process, HTTP.sys), можно (и чаще всего) используется вместе с обратным прокси сервером (nginx, IIS).

### Задания
1. Вспомнить, с какими схемами работал (IIS, nginx, Kestrel).

	**Решение:**
	
	Работал изначально с Kestrel, который используется автоматически в Visual Studio, а при развертывании в производственной среде использовал IIS, In-process hosting. Тогда ещё не особо понимал, чем отличается In-process от Out-of-process модели. Сейчас работаю в Kubernetes, где обратный прокси nginx. Не до конца пока понимаю весь конвеер работы, но постепенно разбираюсь.

2. Изучите шаблон `Strangler Fig` и его применимость в контексте ASP.NET Core.

	**Решение:**
	
	Шаблон применяется для модернизации устаревших систем. Суть метода в том, чтобы в целях модернизации мы не меняли существующие проекты, а создали новый, в который заложили бы (архитектурно) почву для нужных нам изменений. Новый функционал добавляли в новый проект, старый функционал постепенно тоже переносили в него. Если требуется выполнение старого неперенесенного функционала, то его исполнение адресуется старому проекту, если нового или уже перенесенного, то новому. В контексте ASP.NET Core это связано с предлагаемым Microsoft подходом к миграции с ASP.NET Framework на ASP.NET Core `https://learn.microsoft.com/en-us/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`. Подход описывается как хорошо работающий для старых монолитов или систем тип "Черный ящик", функционал которых менять опасно. Основное что необходимости здесь в целом, так это проксирование трафика через новое приложение. При необходимости можем переключиться/откатиться на старый функционал (мы его не меняли). Интересная для меня статья по теме `https://habr.com/ru/companies/kuper/articles/849730/`. А здесь предлагается пример небольшой реализации паттерна на ASP.NET Core `https://code-maze.com/csharp-strangler-fig-architectural-pattern/`.

3. Изучите `Yarp`. Опробуйте его как прокси-сервер для вашего приложения. Имулируйте в двух проектах (или в одном через разные наборы эндпоинтов), что вы переходите с легаси кода на новый. Вам нужно сделать приложение, через которое будут проходить все запросы, и оно либо будет само обрабатывать ответ, либо перенаправлять на 'legacy' проект через `Yarp`.
    
	Ссылки для справки:

	* `https://learn.microsoft.com/ru-ru/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`
	* `https://dotnet.github.io/yarp/`
	
	
	**Решение:**
    
    Выполнил задание, заодно поигрался с маршрутизацией, на практике вспомнил, что `WebApplication.Run` является терминальным middleware, а не endpoint. А это значит, что он выполниться раньше любого определенного endpoint (если только нет хитрого разветвления через `Map()`). Проксирование сработало, раньше этой библиотеки не видел, буду иметь ввиду если нужно будет что-то такое лёгкое быстро реализовать. Из близких аналогов есть ещё `Ocelot`. 
    
    Хорошая презентация: `https://dotnext.ru/archive/2024/talks/5c9277abd9954b36b91671a9fcfa1f38/`.
	
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%202/Exercise%203/AppBuilder.cs`
    
	

## Глава 3. Наше первое приложение
Kestrel получая низкоуровневый запрос преобразует его в `HttpContext`. Этот `HttpContext` дальше путешествует по конвееру и обратно уже с готовым ответом. Ответ передается Kestrel и отдается наружу (на обратный прокси/сервер и т.д.)

Для командной строки:
* Создать решение: `dotnet new sln -n WebApplication1`
* Создать проект (`--use-program-main` для явной функции `Main`): `dotnet new web -o WebApplication1`
* Добавить проект в решение: `dotnet sln add WebApplication1`

Внутри проекта:
Восстановить зависимости: `dotnet restore`;
Сборка (неяно запускает `dotnet restore`, чтобы скипнуть `--no-restore`): `dotnet build`;
Запуск (неявно запускает `dotnet restore`, `dotnet build`, чтобы скипнуть `--no-restore --bo-build`): `dotnet run`.
Добавить nuget пакет: `dotnet add package <packagename>`

> ### Альтернативы CreateBuilder
> Надо опробовать в действии: `CreateSlimBuilder` и `CreateEmptyBuilder`.
> 
> **`CreateEmptyBuilder`** звучит интересно, но он совсем не документирован, тяжело найти информацию о том, как настроить его с нуля не зная внутренностей WebApplicationBuilder. С другой стороны побуждает выяснять, как оно работает изнутри) 
> 
> В любом случае настроил базовый мини пример запуска чисто для прослушки одного порта. 
>
> **`CreateSlimBuilder`** больше документации, скорее всего его может хватить для многих приложений, позволяет урезать лишние модули. 
>
> **Меньше лишних модулей -> меньше сложностей настроек -> проще разработка.**
> https://andrewlock.net/exploring-the-dotnet-8-preview-comparing-createbuilder-to-the-new-createslimbuilder-method/
> https://sd.blackball.lv/en/articles/read/19465-a-dive-into-net-8-native-aot-and-efficient-web-development
> https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
>
> **`CreateBuilder`** автоматически добавляет маршрутизацию (RoutingMiddleware), EnpointMiddleware, компонент обработки ошибок в окружении разработки и другое.
>
> Для тестов по ходу изучения книги будет полезно: https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host
>
> Также в главе 30 настройка приложения через универсальный IHost с большим контролем, нежели WebApplication.

Далее по ходу главы нам напоминают про конвеер, важность его порядка, DI, IOC.

### Задания

1. Создать приложение, которое пробует разные способы настройки приложения (**`CreateEmptyBuilder`**, **`CreateSlimBuilder`**, **`CreateBuilder`**). Собрать и запустить приложение консольными командами. Попробуйте захостить их одновременно)

	**Решение:**
    Выполнил задание. Настройки для минимального примера `CreateSlimBuilder` и `CreateBuilder` не отличались, по умолчанию все само выставляется. А вот для `CreateEmptyBuilder` пришлось немножко помучиться, чтобы выудить из документации что под капотом обычно вызывается у `CreateBuilder` например и что нужно для запуска минимального примера с прослушкой одного порта.
    
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%203/Exercise%201/AppBuilder.cs`
    

## Глава 4. Обработка ошибок с помощью конвейера промежуточного ПО
> Ох, создание своих middleware расмматривается только в 31 главе...

Middleware может:
* при перехвате входящего запроса:
    * обработать его и вернуть ответ; 
    * обработать его и направить дальшей по конвееру;
* при перехвате исходящего ответа:
    * обработать его и направить дальше по конвееру;
    * обработать его и направить сразу на веб-сервер ASP.NET Core.

> ### Run, Use, Map
> * `IApplicationBuilder.Run()` - терминальный компонент (завершающий запрос)
> * `IApplicationBuilder.Use()` - создает middleware, который позволяет (но не обызывает) передать обработку запроса следующим в конвеере компонентам.
>    * `UseWhen()` - ответвление конвеера по условию. Отличие от MapWhen() в том, что может вернуть управление в основную ветвь если не содержит промежуточный терминальный уровень. (т.е. вошло в `UseWhen`, выполнилось, вызвало внутри `await Next()` и двигается дальше от вызова `UseWhen` по конвееру).
> * `IApplicationBuilder.Map()` - позволяет резветвить конвейер на основе пути запроса. Может включать подветви (другие map).
>    * `MapWhen()` - ответвление конвеера по условию (вместо просто пути).

**ASP.NET Core автоматически добавляет "фиктивный" компонент `EndpointMiddleware` в конец конвеера, который при вызове всегда возвращает ответ с ошибкой 404 (`CreateBuilder`, `CreateSlimBuilder`). Также добавляется компонент страницы исключений разработчика `app.UseDeveloperExceptionPage()` в окружении разработки (`app.Environment.IsDevelopment`).**
> Вот как оно оказывается работает.

**Коды ошибок:**
* **1xx** - информационные. Общее подтверждение.
* **2xx** - успешно.
* **3xx** - перенаправление.
* **4xx** - ошибка клиента.
* **5xx** - ошибка сервера.

**Добавляют** компоненты в конвеер методы `Use*()`. Такова конвенция. А метод `app.MapGet("/", () => "Hello World!");` **определяет конечную точку**, которая используется компонентом маршрутизации `app.UseRouting();` (т.е. не добавляет новый компонент, middleware).

Ручное включение уже определенных аватоматически компонентов позволяет изменить их порядок (он встанет там, где вы его определелили).

Для обработки исключений в промышленном окружении можно использовать `ExceptionHandlerMiddleware`. Простой способ добавления: `app.UseExceptionHandler("/error")`. Указывается путь к старнице с ошибки. Middleware вызовет этот путь после перехвата исключения для генерации конечного ответа.

Как работает:
1. Какой-нибудь middleware выбрасывает исключение;
2. `ExceptionHandlerMiddleware` перехватывает исключение;
3. Удаляет любой определенный к этому моменту **частичный** ответ пользователю.
4. Перезаписывает путь запроса на `path`, на который указаывает `app.UseExceptionHandler("path")`;
5. Отправляет запрос обратно по конвееру так, будто он был изначально направлен по пути `path`;
6. Конвеер генерирует новый ответ как обычно;
7. Когда ответ снова возвращается в `ExceptionHandlerMiddleware`, он изменяет `StatusCode` ответа на `500` и продолжает передачу ответа по конвееру на веб-сервер.

Если ошибка произойдет после повторного отправления запроса по конвееру и он снова вернётся в `ExceptionHandlerMiddleware`, то он позволит исключению дойти до самого верха конвеера. Сервер вернёт клиенту низкоуровневую ошибку с `StatusCode` ответа `500`.

Альтернативный подход для обработки ошибок представлен по ссылке `https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`.

Последующие middleware после `ExceptionHandlerMiddleware` будут считать повторное выполнение как новый запрос, а предыдущие не узнают, что произошло что-то необычное.

> **Важный нюанс!** Middleware может изменять ответ, сгенерированный компонентами далее по конвееру только если ответ не был отправлен клиенту. Например, если возникла ошибка, когда отправляется статический файл клиенту, может начаться немедленная потоковая передача байтов клиенту (из соображений производительности). В этом случае компонент обработки ошибок не сможет запуститься, т.к. он не может сбросить ответ. С этим мало что можно сделать.

**WebApplication** автоматом добавляет (по необходимости) следующие компоненты:
1. `HostFilteringMiddleware`. Безопасность. Ограничивает хосты, по которым можно обращаться к приложению. Защищает от нескольких типов атак. Было бы интересно попробовать воспроизвести эти типы атак. Можно больше почитать по `https://andrewlock.net/adding-host-filtering-to-kestrel-in-aspnetcore/`

2. `HostFilteringMiddleware`. Управляет обработкой пересылаемых заголовков. Подробнее будет изучено в главе 27.

3. `DeveloperExceptionMiddleware`. В окружении разработки (`app.Environment.IsDevelopment`) добавляется при запуске приложения. Выводит детальную информацию об возникшем ислючении.

4. `RoutingMiddleware`. Если добавляются конечные точки в приложение, то вызывается метод `UseRouting`, причём до добавления в приложение какого-либо собственного (добавленного разработчиком) компонента.

5. `AuthenticationMiddleware`. Если настраивается аутентификация, то этот компонент аутентифицирует пользователя. Рассматривается в главе 23.

6. `AuthorizationMiddleware`. Запускается после аутентификации. Определяет разрешения пользователя на выполнения ednpoint-а. Если нет прав, то запрос прерывается. Подробнее в главе 24.

7. `EndpointMiddleware`. Соединятся с `RouttingMiddleware` для выполнения конечной точки. Добавляется в конвеере в конец, после любых других компонентов, которые настраиваются в `Program.cs`.

> Но в зависимости от конфигурации `WebApplication` может не создавать эти компоненты + можно переопределить их порядок если самому объявить их.

### Задания
1. Изучить статью. Попробовать повторить подходы в ней (стандартный и через отдельный middleware) комбинируя их так, чтобы исключение в любом случае было обработано.
`https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`

	**Решение:**
    Выполнил задание. Все заработало так, как и ожидалось. По пути немного поизучал и поработал с более низкоуровневым `HttpContext`, обнаружил полезный сервис для формирования ответов с ошибками `IProblemDetailsService`, до этого напрямую его не использовал.
    
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%203/Exercise%201/AppBuilder.cs`

## Глава 5. Создание JSON API с помощью минимальных API

> Для изучения Blazor рекомендутеся книга "Blazor in action" Криса Сейнта.

HTTP API, JSON API, REST API.

gRPC, GraphQL.
> * Для изучения gRPC рекомендуется `https://docs.microsoft.com/aspnet/core/grpc`.
> * Для изучения GraphQL рекомендуется книга "Создание веб-API с помощью ASP.NET Core" Валерио Де Санктис.

**Параметризированные маршруты**

`app.MapGet("person/{name}", (string name) => ...);`

По умолчанию ответ десериализуется в JSON.

* GET - `MapGet(path, handler)`. Только получение данных. Можно кешировать.
* POST - `MapPost(path, handler)`. Создание нового ресурса.
* PUT - `MapPut(path, handler)`. Создание или замена существующего ресурса.
* DELETE - `MapDelete(path, handler)`. Удаление данного ресурса.
* PATCH - `MapPatch(path, handler)`. Изменение данного ресурса.
* Несколько методов - `MapMethods(path, methods, handler)`. Несколько операций.
* Все методы - `Map(path, handler)`. Несколько операций.
* Все методы - `MapFollback(handler)`. Для резервных маршрутов. Вызывается при отсутсвии совпадений по другим конечным точкам. Подробнее `https://weblog.west-wind.com/posts/2020/Jul/12/Handling-SPA-Fallback-Paths-in-a-Generic-ASPNET-Core-Server`.

Если определена например только `app.MapGet("person/{name}, string name => ...);`, а мы стучимся POST методом, то обработчик не запуститься, а вернётся `405 Method Not Allowed`.

Если определена конечная точка напр. `app.MapPost("person/{id}", AddPerson);` и `void AddPerson(int id, Person person)`, то `person` будет создан из десериализованного JSON-объекта из `Body` запроса, что работает для сложных типов (их невозможно извлечь из URL запроса). **В minimal-api данные могут быть привязаны к телу запроса только в формате JSON.**

### Задания
1) Изучить разницу между HTTP API, JSON API, REST API.

2) Изучить (обзорно) gRPC, GraphQL

3) Ознакомиться с введением в HTTP от Firefox `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview`.


## Планы на потом.
1. Вернуться к Глава 4 Задание 1 Решение 1.1. Опробовать воспроизвести типы атак, от которых должен защищать правильно настроенный`HostFilteringMiddleware`.