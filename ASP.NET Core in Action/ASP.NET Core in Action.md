## Глава 1. Начало работы с ASP.NET Core
Варианты использования:
1. Минимальные API (для мелочи);
2. web-api (классика)
3. gRPC API (для внутренних сервисов);
4. MVC (классика);
5. Razor Pages (отрисовка на стороне сервера, модная замена MVC);
6. Blazor WebAssembly.
Выполнение на клиенте (WebAssembly, WASM), в т.ч. автономно; UI на C# в браузере.
7. Blazor Server
Выполнение на сервере, WebSockets для взаимодействия.
8. Blazor гибрид (предыдущих двух режимов);
9. API с классическим фронтом Angular, React, Vue.

К сожалению (легко скрыть бардак) построен вокруг DI, стараюсь как минимум для контроллеров и их зависимостей уходить от этого и собирать их явно.

Основные принципы работы:
1. Конвеер;
2. Kestrel или аналог.
3. HttpContext;

## Глава 2. Что такое ASP.NET Core
Зачем? Динамика (изменение). Для статики хватит статического сайта.

Kestrel убрал жесткую зависимость от IIS.
Можно использовать аналоги Kestrel (IIS in process, HTTP.sys), можно (и чаще всего) используется вместе с обратным прокси сервером (nginx, IIS).

## Глава 3. Наше первое приложение
Kestrel получая низкоуровневый запрос преобразует его в HttpContext.
Этот HttpContext дальше путешествует по конвееру и обратно уже с готовым ответом.
Ответ передается Kestrel и отдается наружу (на обратный прокси/сервер и т.д.)

Для командной строки:
* Создать решение: `dotnet new sln -n WebApplication1`
* Создать проект (`--use-program-main` для явной функции `Main`): `dotnet new web -o WebApplication1`
* Добавить проект в решение: `dotnet sln add WebApplication1`

Внутри проекта:
Восстановить зависимости: `dotnet restore`;
Сборка (неяно запускает `dotnet restore`, чтобы скипнуть `--no-restore`): `dotnet build`;
Запуск (неявно запускает `dotnet restore`, `dotnet build`, чтобы скипнуть `--no-restore --bo-build`): `dotnet run`.
Добавить nuget пакет: `dotnet add package <packagename>`

> ### Альтернативы CreateBuilder
> Надо опробовать в действии: `CreateSlimBuilder` и `CreateEmptyBuilder`.
> 
> **CreateEmptyBuilder** звучит интересно, но он совсем не документирован, тяжело найти информацию о том, как настроить его с нуля не зная внутренностей WebApplicationBuilder. С другой стороны побуждает выяснять, как оно работает изнутри) 
> 
> В любом случае настроил базовый мини пример запуска чисто для прослушки одного порта. 
>
> **CreateSlimBuilder** больше документации, скорее всего его может хватить для многих приложений, позволяет урезать лишние модули. 
>
> **Меньше лишних модулей -> меньше сложностей настроек -> проще разработка.**
> https://andrewlock.net/exploring-the-dotnet-8-preview-comparing-createbuilder-to-the-new-createslimbuilder-method/
> https://sd.blackball.lv/en/articles/read/19465-a-dive-into-net-8-native-aot-and-efficient-web-development
> https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
>
> **CreateBuilder** автоматически добавляет маршрутизацию (RoutingMiddleware), EnpointMiddleware, компонент обработки ошибок в окружении разработки.
>
> Для тестов по ходу изучения книги будет полезно: https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host
>
> Также в главе 30 настройка приложения через универсальный IHost с большим контролем, нежели WebApplication.

Далее по ходу главы нам напоминают про конвеер, важность его порядка, DI, IOC.

## Глава 4. Обработка ошибок с помощью конвейера промежуточного ПО
> Ох, создание своих middleware расмматривается только в 31 главе...

Middleware может:
* при перехвате входящего запроса:
    * обработать его и вернуть ответ; 
    * обработать его и направить дальшей по конвееру;
* при перехвате исходящего ответа:
    * обработать его и направить дальше по конвееру;
    * обработать его и направить сразу на веб-сервер ASP.NET Core.

> ### Run, Use, Map
> * `IApplicationBuilder.Run()` - терминальный компонент (завершающий запрос)
> * `IApplicationBuilder.Use()` - создает middleware, который позволяет (но не обызывает) передать обработку запроса следующим в конвеере компонентам.
>    * `UseWhen()` - ответвление конвеера по условию. Отличие от MapWhen() в том, что может вернуть управление в основную ветвь если не содержит промежуточный терминальный уровень. (т.е. вошло в `UseWhen`, выполнилось, вызвало внутри `await Next()` и двигается дальше от вызова `UseWhen` по конвееру).
> * `IApplicationBuilder.Map()` - позволяет резветвить конвейер на основе пути запроса. Может включать подветви (другие map).
>    * `MapWhen()` - ответвление конвеера по условию (вместо просто пути).