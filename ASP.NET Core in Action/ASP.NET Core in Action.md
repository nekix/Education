## Глава 1. Начало работы с ASP.NET Core
Варианты использования:
1. Минимальные API (для мелочи);
2. web-api (классика)
3. gRPC API (для внутренних сервисов);
4. MVC (классика);
5. Razor Pages (отрисовка на стороне сервера, модная замена MVC);
6. Blazor WebAssembly.
Выполнение на клиенте (WebAssembly, WASM), в т.ч. автономно; UI на C# в браузере.
7. Blazor Server
Выполнение на сервере, WebSockets для взаимодействия.
8. Blazor гибрид (предыдущих двух режимов);
9. API с классическим фронтом Angular, React, Vue.

К сожалению (легко скрыть бардак) построен вокруг DI, стараюсь как минимум для контроллеров и их зависимостей уходить от этого и собирать их явно.

Основные принципы работы:
1. Конвеер;
2. Kestrel или аналог.
3. HttpContext;

### Задания

1. Подумай, какие бы шаблоны проектов ты бы выбрал для каких задач.

2. Создай приложение по минимальному шаблону ASP.NET Core. Отключи все предлагаемые галочки.

## Глава 2. Что такое ASP.NET Core
Зачем нужна платформа ASP.NET Core в контексте веб разработки? Для динамики (изменений, поведений). Для статики хватит статического сайта.

Kestrel убрал жесткую зависимость от IIS.
Можно использовать аналоги Kestrel (IIS in process, HTTP.sys), можно (и чаще всего) используется вместе с обратным прокси сервером (nginx, IIS).

### Задания
1. Вспомнить, с какими схемами работал (IIS, nginx, Kestrel).

2. Изучите шаблон `Strangler Fig` и его применимость в контексте ASP.NET Core.

3. Изучите `Yarp`. Опробуйте его как прокси-сервер для вашего приложения. Имилируйте в двух проектах, что вы переходите с легаси кода на новый. Вам нужно сделать приложение, через которое будут проходить все запросы, и оно либо будет само обрабатывать ответ, либо перенаправлять на 'legacy' проект через `Yarp`.
    
Ссылки для справки:

* `https://learn.microsoft.com/ru-ru/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`
* `https://dotnet.github.io/yarp/`

## Глава 3. Наше первое приложение
Kestrel получая низкоуровневый запрос преобразует его в HttpContext.
Этот HttpContext дальше путешествует по конвееру и обратно уже с готовым ответом.
Ответ передается Kestrel и отдается наружу (на обратный прокси/сервер и т.д.)

Для командной строки:
* Создать решение: `dotnet new sln -n WebApplication1`
* Создать проект (`--use-program-main` для явной функции `Main`): `dotnet new web -o WebApplication1`
* Добавить проект в решение: `dotnet sln add WebApplication1`

Внутри проекта:
Восстановить зависимости: `dotnet restore`;
Сборка (неяно запускает `dotnet restore`, чтобы скипнуть `--no-restore`): `dotnet build`;
Запуск (неявно запускает `dotnet restore`, `dotnet build`, чтобы скипнуть `--no-restore --bo-build`): `dotnet run`.
Добавить nuget пакет: `dotnet add package <packagename>`

> ### Альтернативы CreateBuilder
> Надо опробовать в действии: `CreateSlimBuilder` и `CreateEmptyBuilder`.
> 
> **`CreateEmptyBuilder`** звучит интересно, но он совсем не документирован, тяжело найти информацию о том, как настроить его с нуля не зная внутренностей WebApplicationBuilder. С другой стороны побуждает выяснять, как оно работает изнутри) 
> 
> В любом случае настроил базовый мини пример запуска чисто для прослушки одного порта. 
>
> **`CreateSlimBuilder`** больше документации, скорее всего его может хватить для многих приложений, позволяет урезать лишние модули. 
>
> **Меньше лишних модулей -> меньше сложностей настроек -> проще разработка.**
> https://andrewlock.net/exploring-the-dotnet-8-preview-comparing-createbuilder-to-the-new-createslimbuilder-method/
> https://sd.blackball.lv/en/articles/read/19465-a-dive-into-net-8-native-aot-and-efficient-web-development
> https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
>
> **`CreateBuilder`** автоматически добавляет маршрутизацию (RoutingMiddleware), EnpointMiddleware, компонент обработки ошибок в окружении разработки и другое.
>
> Для тестов по ходу изучения книги будет полезно: https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host
>
> Также в главе 30 настройка приложения через универсальный IHost с большим контролем, нежели WebApplication.

Далее по ходу главы нам напоминают про конвеер, важность его порядка, DI, IOC.

### Задания

1. Создать приложение, которое пробует разные способы настройки приложения (**`CreateEmptyBuilder`**, **`CreateSlimBuilder`**, **`CreateBuilder`**). Собрать и запустить приложение консольными командами. Попробуйте захостить их одновременно)

## Глава 4. Обработка ошибок с помощью конвейера промежуточного ПО
> Ох, создание своих middleware расмматривается только в 31 главе...

Middleware может:
* при перехвате входящего запроса:
    * обработать его и вернуть ответ; 
    * обработать его и направить дальшей по конвееру;
* при перехвате исходящего ответа:
    * обработать его и направить дальше по конвееру;
    * обработать его и направить сразу на веб-сервер ASP.NET Core.

> ### Run, Use, Map
> * `IApplicationBuilder.Run()` - терминальный компонент (завершающий запрос)
> * `IApplicationBuilder.Use()` - создает middleware, который позволяет (но не обызывает) передать обработку запроса следующим в конвеере компонентам.
>    * `UseWhen()` - ответвление конвеера по условию. Отличие от MapWhen() в том, что может вернуть управление в основную ветвь если не содержит промежуточный терминальный уровень. (т.е. вошло в `UseWhen`, выполнилось, вызвало внутри `await Next()` и двигается дальше от вызова `UseWhen` по конвееру).
> * `IApplicationBuilder.Map()` - позволяет резветвить конвейер на основе пути запроса. Может включать подветви (другие map).
>    * `MapWhen()` - ответвление конвеера по условию (вместо просто пути).

**ASP.NET Core автоматически добавляет "фиктивный" компонент `EndpointMiddleware` в конец конвеера, который при вызове всегда возвращает ответ с ошибкой 404 (`CreateBuilder`, `CreateSlimBuilder`). Также добавляется компонент страницы исключений разработчика `app.UseDeveloperExceptionPage()` в окружении разработки (`app.Environment.IsDevelopment`).**
> Вот как оно оказывается работает.

**Коды ошибок:**
* **1xx** - информационные. Общее подтверждение.
* **2xx** - успешно.
* **3xx** - перенаправление.
* **4xx** - ошибка клиента.
* **5xx** - ошибка сервера.

**Добавляют** компоненты в конвеер методы `Use*()`. Такова конвенция. А метод `app.MapGet("/", () => "Hello World!");` **определяет конечную точку**, которая используется компонентом маршрутизации `app.UseRouting();` (т.е. не добавляет новый компонент, middleware).

Ручное включение уже определенных аватоматически компонентов позволяет изменить их порядок (он встанет там, где вы его определелили).

Для обработки исключений в промышленном окружении можно использовать `ExceptionHandlerMiddleware`. Простой способ добавления: `app.UseExceptionHandler("/error")`. Указывается путь к старнице с ошибки. Middleware вызовет этот путь после перехвата исключения для генерации конечного ответа.

Как работает:
1. Какой-нибудь middleware выбрасывает исключение;
2. `ExceptionHandlerMiddleware` перехватывает исключение;
3. Удаляет любой определенный к этому моменту **частичный** ответ пользователю.
4. Перезаписывает путь запроса на `path`, на который указаывает `app.UseExceptionHandler("path")`;
5. Отправляет запрос обратно по конвееру так, будто он был изначально направлен по пути `path`;
6. Конвеер генерирует новый ответ как обычно;
7. Когда ответ снова возвращается в `ExceptionHandlerMiddleware`, он изменяет `StatusCode` ответа на `500` и продолжает передачу ответа по конвееру на веб-сервер.

Если ошибка произойдет после повторного отправления запроса по конвееру и он снова вернётся в `ExceptionHandlerMiddleware`, то он позволит исключению дойти до самого верха конвеера. Сервер вернёт клиенту низкоуровневую ошибку с `StatusCode` ответа `500`.

Альтернативный подход для обработки ошибок представлен по ссылке `https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`.

Последующие middleware после `ExceptionHandlerMiddleware` будут считать повторное выполнение как новый запрос, а предыдущие не узнают, что произошло что-то необычное.

> **Важный нюанс!** Middleware может изменять ответ, сгенерированный компонентами далее по конвееру только если ответ не был отправлен клиенту. Например, если возникла ошибка, когда отправляется статический файл клиенту, может начаться немедленная потоковая передача байтов клиенту (из соображений производительности). В этом случае компонент обработки ошибок не сможет запуститься, т.к. он не может сбросить ответ. С этим мало что можно сделать.

### Задания
1. Выяснить какие middleware автоматом добавляет ASP.NET Core в конвеер (для `CreateBuilder`, `CreateSlimBuilder`, `CreateEmptyBuilder`).
    
    **Решение:**
    
    1. `CreateBuilder` добавляет следующие компоненты:
        
        1.1.`HostFilteringMiddleware`. Безопасность. Ограничивает хосты, по которым можно обращаться к приложению. Защищает от нескольких типов атак. Было бы интересно попробовать воспроизвести эти типы атак. Можно больше почитать по `https://andrewlock.net/adding-host-filtering-to-kestrel-in-aspnetcore/`
        
        2.2 `HostFilteringMiddleware`. Управляет обработкой пересылаемых заголовков. Подробнее будет изучено в главе 27.
        
        2.3 `DeveloperExceptionMiddleware`. В окружении разработки (`app.Environment.IsDevelopment`) добавляется при запуске приложения. Выводит детальную информацию об возникшем ислючении.
        
        2.4 `RoutingMiddleware`. Если добавляются конечные точки в приложение, то вызывается метод `UseRouting`, причём до добавления в приложение какого-либо собственного (добавленного разработчиком) компонента.
        
        2.5 `AuthenticationMiddleware`. Если настраивается аутентификация, то этот компонент аутентифицирует пользователя. Рассматривается в главе 23.
        
        2.6 `AuthorizationMiddleware`. Запускается после аутентификации. Определяет разрешения пользователя на выполнения ednpoint-а. Если нет прав, то запрос прерывается. Подробнее в главе 24.
        
        2.7. `EndpointMiddleware`. Соединятся с `RouttingMiddleware` для выполнения конечной точки. Добавляется в конвеере в конец, после любых других компонентов, которые настраиваются в `Program.cs`.
        
        > Но в зависимости от конфигурации `WebApplication` может не создавать эти компоненты + можно переопределить их порядок если самому объявить их.

2. Изучить статью. Попробовать повторить.
`https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`

3. Создайте приложение, которое будет возвращать состав и порядок текущего конвеера промежуточного ПО. Другая конечная точка пусть возвращает информацию о структуре приложения (папки, файлы), третье пусть отображает зависимости приложения. Четвертая конечная точка будет выбрасывать исключение которое должно перехватываться и обрабатываться.

## Глава 5. Создание JSON API с помощью минимальных API

> Для изучения Blazor рекомендутеся книга "Blazor in action" Криса Сейнта.

HTTP API, JSON API, REST API.

gRPC, GraphQL.
> * Для изучения gRPC рекомендуется `https://docs.microsoft.com/aspnet/core/grpc`.
> * Для изучения GraphQL рекомендуется книга "Создание веб-API с помощью ASP.NET Core" Валерио Де Санктис.

**Параметризированные маршруты**

`app.MapGet("person/{name}", (string name) => ...);`

По умолчанию ответ десериализуется в JSON.

* GET - `MapGet(path, handler)`. Только получение данных. Можно кешировать.
* POST - `MapPost(path, handler)`. Создание нового ресурса.
* PUT - `MapPut(path, handler)`. Создание или замена существующего ресурса.
* DELETE - `MapDelete(path, handler)`. Удаление данного ресурса.
* PATCH - `MapPatch(path, handler)`. Изменение данного ресурса.
* Несколько методов - `MapMethods(path, methods, handler)`. Несколько операций.
* Все методы - `Map(path, handler)`. Несколько операций.
* Все методы - `MapFollback(handler)`. Для резервных маршрутов. Вызывается при отсутсвии совпадений по другим конечным точкам. Подробнее `https://weblog.west-wind.com/posts/2020/Jul/12/Handling-SPA-Fallback-Paths-in-a-Generic-ASPNET-Core-Server`.

Если определена например только `app.MapGet("person/{name}, string name => ...);`, а мы стучимся POST методом, то обработчик не запуститься, а вернётся `405 Method Not Allowed`.

Если определена конечная точка напр. `app.MapPost("person/{id}", AddPerson);` и `void AddPerson(int id, Person person)`, то `person` будет создан из десериализованного JSON-объекта из `Body` запроса, что работает для сложных типов (их невозможно извлечь из URL запроса). **В minimal-api данные могут быть привязаны к телу запроса только в формате JSON.**

### Задания
1) Изучить разницу между HTTP API, JSON API, REST API.

2) Изучить (обзорно) gRPC, GraphQL

3) Ознакомиться с введением в HTTP от Firefox `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview`.


## Планы на потом.
1. Вернуться к Глава 4 Задание 1 Решение 1.1. Опробовать воспроизвести типы атак, от которых должен защищать правильно настроенный`HostFilteringMiddleware`.