## Глава 1. Начало работы с ASP.NET Core
Варианты использования:
1. Минимальные API (для мелочи);
2. web-api (классика)
3. gRPC API (для внутренних сервисов);
4. MVC (классика);
5. Razor Pages (отрисовка на стороне сервера, модная замена MVC);
6. Blazor WebAssembly.
Выполнение на клиенте (WebAssembly, WASM), в т.ч. автономно; UI на C# в браузере.
7. Blazor Server
Выполнение на сервере, WebSockets для взаимодействия.
8. Blazor гибрид (предыдущих двух режимов);
9. API с классическим фронтом Angular, React, Vue.

К сожалению (легко скрыть бардак) построен вокруг DI, стараюсь по возможности для контроллеров и их зависимостей уходить от этого и собирать их явно.

Основные принципы работы:
1. Конвеер;
2. Kestrel или аналог.
3. HttpContext;

### Задания

1. Подумай, какие бы шаблоны проектов ты бы выбрал для каких задач.

    **Решение:**
    
    1. minimap-api - для простых внутренних сервисов;
	2. web-api, api с фронтом на Angular, React, Vue - всегда, когда не нужен UI, илю UI отдельно в напр. Angular, React проектах;
	3. gRPC API - с ним не работал, так что на данный момент только если этот протокол уже будет устоявшимся в системе, с которой мне нужно будет работать;
	4. MVC, Razor pages - когда есть UI. MVC в сравнении с Razor pages для себя разницы особой не вижу, выбирал бы MVC, если бы большая часть команды уже с ним работала, в иных случаях Razor pages, они показались более быстрыми для разработки.
	5. Blazor WebAssembly, Blazor Server, Blazor гибрид - если бы предоставили выбор и время на изучение, то попробовал сделать проект на нем. Заманчиво звучит большая независимость от HTML, CSS, JS, да и сам WASM. Но с другой стороны, когда я их пробовал, для них было малова-то хороших библиотек компонентов, по сравнению с классическим JS, TYPESCRIPT.

2. Создай приложение для будущих заданий по минимальному шаблону ASP.NET Core. Отключи все предлагаемые галочки.
	
	**Решение:**
	
	Проект создан и доступен по ссылке: `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore`

## Глава 2. Что такое ASP.NET Core
Зачем нужна платформа ASP.NET Core в контексте веб разработки? Для динамики (изменений, поведений). Для статики хватит статического сайта.

Kestrel убрал жесткую зависимость от IIS.
Можно использовать аналоги Kestrel (IIS in process, HTTP.sys), можно (и чаще всего) используется вместе с обратным прокси сервером (nginx, IIS).

### Задания
1. Вспомнить, с какими схемами работал (IIS, nginx, Kestrel).

	**Решение:**
	
	Работал изначально с Kestrel, который используется автоматически в Visual Studio, а при развертывании в производственной среде использовал IIS, In-process hosting. Тогда ещё не особо понимал, чем отличается In-process от Out-of-process модели. Сейчас работаю в Kubernetes, где обратный прокси nginx. Не до конца пока понимаю весь конвеер работы, но постепенно разбираюсь.

2. Изучите шаблон `Strangler Fig` и его применимость в контексте ASP.NET Core.

	**Решение:**
	
	Шаблон применяется для модернизации устаревших систем. Суть метода в том, чтобы в целях модернизации мы не меняли существующие проекты, а создали новый, в который заложили бы (архитектурно) почву для нужных нам изменений. Новый функционал добавляли в новый проект, старый функционал постепенно тоже переносили в него. Если требуется выполнение старого неперенесенного функционала, то его исполнение адресуется старому проекту, если нового или уже перенесенного, то новому. В контексте ASP.NET Core это связано с предлагаемым Microsoft подходом к миграции с ASP.NET Framework на ASP.NET Core `https://learn.microsoft.com/en-us/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`. Подход описывается как хорошо работающий для старых монолитов или систем тип "Черный ящик", функционал которых менять опасно. Основное что необходимости здесь в целом, так это проксирование трафика через новое приложение. При необходимости можем переключиться/откатиться на старый функционал (мы его не меняли). Интересная для меня статья по теме `https://habr.com/ru/companies/kuper/articles/849730/`. А здесь предлагается пример небольшой реализации паттерна на ASP.NET Core `https://code-maze.com/csharp-strangler-fig-architectural-pattern/`.

3. Изучите `Yarp`. Опробуйте его как прокси-сервер для вашего приложения. Имулируйте в двух проектах (или в одном через разные наборы эндпоинтов), что вы переходите с легаси кода на новый. Вам нужно сделать приложение, через которое будут проходить все запросы, и оно либо будет само обрабатывать ответ, либо перенаправлять на 'legacy' проект через `Yarp`.
    
	Ссылки для справки:

	* `https://learn.microsoft.com/ru-ru/aspnet/core/migration/inc/overview?view=aspnetcore-9.0`
	* `https://dotnet.github.io/yarp/`
	
	
	**Решение:**
    
    Выполнил задание, заодно поигрался с маршрутизацией, на практике вспомнил, что `WebApplication.Run` является терминальным middleware, а не endpoint. А это значит, что он выполниться раньше любого определенного endpoint (если только нет хитрого разветвления через `Map()`). Проксирование сработало, раньше этой библиотеки не видел, буду иметь ввиду если нужно будет что-то такое лёгкое быстро реализовать. Из близких аналогов есть ещё `Ocelot`. 
    
    Хорошая презентация: `https://dotnext.ru/archive/2024/talks/5c9277abd9954b36b91671a9fcfa1f38/`.
	
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%202/Exercise%203/AppBuilder.cs`
    
	

## Глава 3. Наше первое приложение
Kestrel получая низкоуровневый запрос преобразует его в `HttpContext`. Этот `HttpContext` дальше путешествует по конвееру и обратно уже с готовым ответом. Ответ передается Kestrel и отдается наружу (на обратный прокси/сервер и т.д.)

Для командной строки:
* Создать решение: `dotnet new sln -n WebApplication1`
* Создать проект (`--use-program-main` для явной функции `Main`): `dotnet new web -o WebApplication1`
* Добавить проект в решение: `dotnet sln add WebApplication1`

Внутри проекта:
Восстановить зависимости: `dotnet restore`;
Сборка (неяно запускает `dotnet restore`, чтобы скипнуть `--no-restore`): `dotnet build`;
Запуск (неявно запускает `dotnet restore`, `dotnet build`, чтобы скипнуть `--no-restore --bo-build`): `dotnet run`.
Добавить nuget пакет: `dotnet add package <packagename>`

> ### Альтернативы CreateBuilder
> Надо опробовать в действии: `CreateSlimBuilder` и `CreateEmptyBuilder`.
> 
> **`CreateEmptyBuilder`** звучит интересно, но он совсем не документирован, тяжело найти информацию о том, как настроить его с нуля не зная внутренностей WebApplicationBuilder. С другой стороны побуждает выяснять, как оно работает изнутри) 
> 
> В любом случае настроил базовый мини пример запуска чисто для прослушки одного порта. 
>
> **`CreateSlimBuilder`** больше документации, скорее всего его может хватить для многих приложений, позволяет урезать лишние модули. 
>
> **Меньше лишних модулей -> меньше сложностей настроек -> проще разработка.**
> https://andrewlock.net/exploring-the-dotnet-8-preview-comparing-createbuilder-to-the-new-createslimbuilder-method/
> https://sd.blackball.lv/en/articles/read/19465-a-dive-into-net-8-native-aot-and-efficient-web-development
> https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
>
> **`CreateBuilder`** автоматически добавляет маршрутизацию (RoutingMiddleware), EnpointMiddleware, компонент обработки ошибок в окружении разработки и другое.
>
> Для тестов по ходу изучения книги будет полезно: https://khalidabuhakmeh.com/hosting-two-aspnet-core-apps-in-one-host
>
> Также в главе 30 настройка приложения через универсальный IHost с большим контролем, нежели WebApplication.

Далее по ходу главы нам напоминают про конвеер, важность его порядка, DI, IOC.

### Задания

1. Создать приложение, которое пробует разные способы настройки приложения (**`CreateEmptyBuilder`**, **`CreateSlimBuilder`**, **`CreateBuilder`**). Собрать и запустить приложение консольными командами. Попробуйте захостить их одновременно)

	**Решение:**
    Выполнил задание. Настройки для минимального примера `CreateSlimBuilder` и `CreateBuilder` не отличались, по умолчанию все само выставляется. А вот для `CreateEmptyBuilder` пришлось немножко помучиться, чтобы выудить из документации что под капотом обычно вызывается у `CreateBuilder` например и что нужно для запуска минимального примера с прослушкой одного порта.
    
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%203/Exercise%201/AppBuilder.cs`
    

## Глава 4. Обработка ошибок с помощью конвейера промежуточного ПО
> Ох, создание своих middleware расмматривается только в 31 главе...

Middleware может:
* при перехвате входящего запроса:
    * обработать его и вернуть ответ; 
    * обработать его и направить дальшей по конвееру;
* при перехвате исходящего ответа:
    * обработать его и направить дальше по конвееру;
    * обработать его и направить сразу на веб-сервер ASP.NET Core.

> ### Run, Use, Map
> * `IApplicationBuilder.Run()` - терминальный компонент (завершающий запрос)
> * `IApplicationBuilder.Use()` - создает middleware, который позволяет (но не обызывает) передать обработку запроса следующим в конвеере компонентам.
>    * `UseWhen()` - ответвление конвеера по условию. Отличие от MapWhen() в том, что может вернуть управление в основную ветвь если не содержит промежуточный терминальный уровень. (т.е. вошло в `UseWhen`, выполнилось, вызвало внутри `await Next()` и двигается дальше от вызова `UseWhen` по конвееру).
> * `IApplicationBuilder.Map()` - позволяет резветвить конвейер на основе пути запроса. Может включать подветви (другие map).
>    * `MapWhen()` - ответвление конвеера по условию (вместо просто пути).

**ASP.NET Core автоматически добавляет "фиктивный" компонент `EndpointMiddleware` в конец конвеера, который при вызове всегда возвращает ответ с ошибкой 404 (`CreateBuilder`, `CreateSlimBuilder`). Также добавляется компонент страницы исключений разработчика `app.UseDeveloperExceptionPage()` в окружении разработки (`app.Environment.IsDevelopment`).**
> Вот как оно оказывается работает.

**Коды ошибок:**
* **1xx** - информационные. Общее подтверждение.
* **2xx** - успешно.
* **3xx** - перенаправление.
* **4xx** - ошибка клиента.
* **5xx** - ошибка сервера.

**Добавляют** компоненты в конвеер методы `Use*()`. Такова конвенция. А метод `app.MapGet("/", () => "Hello World!");` **определяет конечную точку**, которая используется компонентом маршрутизации `app.UseRouting();` (т.е. не добавляет новый компонент, middleware).

Ручное включение уже определенных аватоматически компонентов позволяет изменить их порядок (он встанет там, где вы его определелили).

Для обработки исключений в промышленном окружении можно использовать `ExceptionHandlerMiddleware`. Простой способ добавления: `app.UseExceptionHandler("/error")`. Указывается путь к старнице с ошибки. Middleware вызовет этот путь после перехвата исключения для генерации конечного ответа.

Как работает:
1. Какой-нибудь middleware выбрасывает исключение;
2. `ExceptionHandlerMiddleware` перехватывает исключение;
3. Удаляет любой определенный к этому моменту **частичный** ответ пользователю.
4. Перезаписывает путь запроса на `path`, на который указаывает `app.UseExceptionHandler("path")`;
5. Отправляет запрос обратно по конвееру так, будто он был изначально направлен по пути `path`;
6. Конвеер генерирует новый ответ как обычно;
7. Когда ответ снова возвращается в `ExceptionHandlerMiddleware`, он изменяет `StatusCode` ответа на `500` и продолжает передачу ответа по конвееру на веб-сервер.

Если ошибка произойдет после повторного отправления запроса по конвееру и он снова вернётся в `ExceptionHandlerMiddleware`, то он позволит исключению дойти до самого верха конвеера. Сервер вернёт клиенту низкоуровневую ошибку с `StatusCode` ответа `500`.

Альтернативный подход для обработки ошибок представлен по ссылке `https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`.

Последующие middleware после `ExceptionHandlerMiddleware` будут считать повторное выполнение как новый запрос, а предыдущие не узнают, что произошло что-то необычное.

> **Важный нюанс!** Middleware может изменять ответ, сгенерированный компонентами далее по конвееру только если ответ не был отправлен клиенту. Например, если возникла ошибка, когда отправляется статический файл клиенту, может начаться немедленная потоковая передача байтов клиенту (из соображений производительности). В этом случае компонент обработки ошибок не сможет запуститься, т.к. он не может сбросить ответ. С этим мало что можно сделать.

**WebApplication** автоматом добавляет (по необходимости) следующие компоненты:
1. `HostFilteringMiddleware`. Безопасность. Ограничивает хосты, по которым можно обращаться к приложению. Защищает от нескольких типов атак. Было бы интересно попробовать воспроизвести эти типы атак. Можно больше почитать по `https://andrewlock.net/adding-host-filtering-to-kestrel-in-aspnetcore/`

2. `HostFilteringMiddleware`. Управляет обработкой пересылаемых заголовков. Подробнее будет изучено в главе 27.

3. `DeveloperExceptionMiddleware`. В окружении разработки (`app.Environment.IsDevelopment`) добавляется при запуске приложения. Выводит детальную информацию об возникшем ислючении.

4. `RoutingMiddleware`. Если добавляются конечные точки в приложение, то вызывается метод `UseRouting`, причём до добавления в приложение какого-либо собственного (добавленного разработчиком) компонента.

5. `AuthenticationMiddleware`. Если настраивается аутентификация, то этот компонент аутентифицирует пользователя. Рассматривается в главе 23.

6. `AuthorizationMiddleware`. Запускается после аутентификации. Определяет разрешения пользователя на выполнения ednpoint-а. Если нет прав, то запрос прерывается. Подробнее в главе 24.

7. `EndpointMiddleware`. Соединятся с `RouttingMiddleware` для выполнения конечной точки. Добавляется в конвеере в конец, после любых других компонентов, которые настраиваются в `Program.cs`.

> Но в зависимости от конфигурации `WebApplication` может не создавать эти компоненты + можно переопределить их порядок если самому объявить их.

### Задания
1. Изучить статью. Попробовать повторить подходы в ней (стандартный и через отдельный middleware) комбинируя их так, чтобы исключение в любом случае было обработано.
`https://andrewlock.net/creating-a-custom-error-handler-middleware-function/`

	**Решение:**
    Выполнил задание. Все заработало так, как и ожидалось. По пути немного поизучал и поработал с более низкоуровневым `HttpContext`, обнаружил полезный сервис для формирования ответов с ошибками `IProblemDetailsService`, до этого напрямую его не использовал.
    
    Ссылка на код: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%203/Exercise%201/AppBuilder.cs`

## Глава 5. Создание JSON API с помощью минимальных API

> Для изучения Blazor рекомендутеся книга "Blazor in action" Криса Сейнта.

HTTP API, JSON API, REST API.

gRPC, GraphQL.
> * Для изучения gRPC рекомендуется `https://docs.microsoft.com/aspnet/core/grpc`.
> * Для изучения GraphQL рекомендуется книга "Создание веб-API с помощью ASP.NET Core" Валерио Де Санктис.

**Параметризированные маршруты**

`app.MapGet("person/{name}", (string name) => ...);`

По умолчанию ответ десериализуется в JSON.

* GET - `MapGet(path, handler)`. Только получение данных. Можно кешировать.
* POST - `MapPost(path, handler)`. Создание нового ресурса.
* PUT - `MapPut(path, handler)`. Создание или замена существующего ресурса.
* DELETE - `MapDelete(path, handler)`. Удаление данного ресурса.
* PATCH - `MapPatch(path, handler)`. Изменение данного ресурса.
* Несколько методов - `MapMethods(path, methods, handler)`. Несколько операций.
* Все методы - `Map(path, handler)`. Несколько операций.
* Все методы - `MapFollback(handler)`. Для резервных маршрутов. Вызывается при отсутсвии совпадений по другим конечным точкам. Подробнее `https://weblog.west-wind.com/posts/2020/Jul/12/Handling-SPA-Fallback-Paths-in-a-Generic-ASPNET-Core-Server`.

Если определена например только `app.MapGet("person/{name}, string name => ...);`, а мы стучимся POST методом, то обработчик не запуститься, а вернётся `405 Method Not Allowed`.

Если определена конечная точка напр. `app.MapPost("person/{id}", AddPerson);` и `void AddPerson(int id, Person person)`, то `person` будет создан из десериализованного JSON-объекта из `Body` запроса, что работает для сложных типов (их невозможно извлечь из URL запроса). **В minimal-api данные могут быть привязаны к телу запроса только в формате JSON.**

**Возврат ошибок и статус кодов**

В minimal-api можно возвращать результат операции в `IResult`. Например для возврата статус кодов и ошибок. Для этого используются `Results` и `TypedResults`. Второй проще использовать в модульных тестах за счёт того, что он возвращает не `IResult`, а более конкретный обобщенный тип, например `Ok<T>`.

Сводка статус кодов и их предполагаемого использования для справки: `https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status`

При необходимости большего контроля над ответом можно использовать объект `HttpResponse` в перегрузке по типу `app.MapGet("/path", (HttpResponse response) => { ... });`

**Problem details**

Для возврата ошибок клиентам желательно использовать веб-спецификацию **Problem Details**. Это позволяет предоставлять машиночитаемые ошибки для HTTP API. `https://www.rfc-editor.org/rfc/rfc7807.html`

Для этого можно использовать методы `Results.Problem()`, `Results.ValidationProblem()` и `TypedResults`. Первые два возвращают `ProblemHttpResult`.

**Приведение всех возвращаемых ошибок к Problem Details**

Два класса ошибок, которые обрабатываются по разному:

1. Исключения
2. Ответы с кодом состояния ошибки

Исключения можно обработать с помощью `ExceptionHandlerMiddleware`. Вместо создания отдельной конечной точки для обработки предпочтительнее использование сервиса `IProblemDetailsService`. Его можно добавить так: `builder.Services.AddProblemDetails()`. Если он добавлен и `ExceptionHandlerMiddleware` используется перегрузка без аргументов (без пути к обработчику ошибок), то он автоматически использует зарегистрированный `IProblemDetailsService` для генерации ответа. `DeveloperExceptionPageMiddleware` также поддерживает `IProblemDetailsService` и использует его, если в запросе указано, что он не поддерживает HTTP.

Коды состояния ошибок можно либо на всех конечных точках обеспечить возврат `Problem Details`, либо (не обязательно вместо) добавить `StatusCodePagesMiddleware`. Если через него будет возвращаться ответ с кодом состояния ошибки но без тела ответа, то middleware автоматически добавит `Problem Details` в тело ответа.

> `StatusCodePagesMiddleware` можно также использоваться для повторого выполнения конвеера как в случае с `ExceptionHandlerMiddleware`, но уже в зависимости от кода состояни ошибки перенаправлять на разные enpoint-ы.

**`Result` доп.методы**

* `Results.File()` - возврат файла;
* `Results.Byte()` - возврат двоичных данных;
* `Result.Stream()` - возврат данных асинхронно, через поток.

Для `File` и `Byte` доступен `EnableRangeProcessing` для запроса и передачи диапозона данных. `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests`

**Фильтры конечных точек**

Позволяют вынести отдельно код, который будет выполняться до или после конечной точки. Каждый фильтр привязан к свой конечной точке и срабатаывает только если запрос достиг её. Могут также замкнуть конвеер. Можно добавлять несколько фильтров на одну конечную точку, выполняются аналогично middleware, но только "вокруг" своей конечной точки.

Пример `app.MapGet(...).AddEndpointFilter(...).AddEndpointFilter(...)...;`

Внутри через можно получить аргументы endpoint-а: `context.GetArgument<T>()`.

**Фильтры затрудняют понимание потока приложения, лучше использовать только если в нескольких конечных точках обнаружился одинаковый код и его вынос в фильтры вместо вызова в отдельной функции внутри конечной точки сильно упрощает понимание кода.**

Отличие от middleware:

* Выполняется только для запрос, которые достигли связанный ednpoing;
* Имеют доступ к доп. сведениям о конечной точке, например к возвращаемому значению `IResult`;
* Фильтры действуют более точечно, middleware наоборот ко всем запросам.

**Фабрики фильтров**

Специфичная вещь, позволяет создавать обобщенные фильтры конечных точек, у которых снижена зависимость от реализации endpoint-ов (например от порядка аргументов).

`AddEndpointFactory`

**`IEndpointFactory`**

Аналог определению через лямбда-выражения `AddEndpointFilter`.

**Группы маршрутов**

Используются для извлечения общих сегментов пути или фильтров в одно место.

`app.MapGroup("/groupPath");` => `RouteGroupBuilder`. Для каждого `RouteGroupBuilder` можно вызывать свои `Map` методы, которые сработают только внутри группы. Также и фильтры, вложенные группы.

### Задания
1) Изучить разницу между HTTP API, JSON API, REST API.

    **Решение**
    HTTP API является общим для оставшихся двух понятий. HTTP является протоколом, соответсвенно HTTP API, это API, использующий HTTP для взаимодействия. JSON API в таком случае является соглашением/спецификацией на формат данных для взаимодействия по протоколу HTTP посредством документов формата JSON. REST API же архитектурный стиль, который декларирует способ взаимодействия с сервером, а не формат данных для взаимодействия. REST API и JSON API могут комбинироваться.

2) Реализовать с помощью минимального API и изученных в главе инструментов api для операций read со списком фруктов и овощей. Логируйте эти операции на верхнем уровне (объеденив их в группы). Ошибки должны возвращаться в соответствии с `Problem Details`.
    
    **Решение**
    Реализовал по ссылке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%205/Exercise%202/AppBuilder.cs`. В рамках реализации сделал одну группу для логирования операций к данным конечным точкам, а в них настроил возврат результата через `TypedResults` и `Results`.

## Глава 6. Сопоставление URL-адресов с конечными точками с помощью маршрутизации

Машрутизация - сопоставление входящего запроса с методом, который будет его обрабатывать.

За маршрутизацию ответсвенен компонент маршрутизации.

**Строка запроса не используется системой маршрутизации для определения обработчика**

Руководство Google по SEO для начинающих (чтобы правильно закодировать иерархию сайта): `https://developers.google.com/search/docs/fundamentals/seo-starter-guide?visit_id=638804892081427264-2671799893&rd=1&hl=ru`

Как вариант ещё может использоваться маршрутизация на основе физического расположения обработчика на жестком диске (простота). Razor pages используют оба подхода.

Маршрутизация в ASP.NET Core реализуется с помощью двух компонентов:

* `EnpointRoutingMiddleware` - выбирает конечные точки для обработки запроса;

* `EndpointMiddleware` - вызывает конечную точку выбранную `EnpointRoutingMiddleware`.

Каждая конечная точка (создается вызовом `Map()` на `IEndpointRouteBuilder`, в т.ч. `WebApplication`) связана с **шаблоном маршрута** (шаблоны URL-адреса).

**`RoutingMiddleware` прикрепляет выбранную конечную точку к `HttpContext`.

**Синтаксис шаблона маршрута**

Маршрут разбивается на сегменты, которые обычно отделяются `/`. Можно использовать и другой разделитель (сложный сегмент), но это не рекомендуется из-за их особенностей (`https://learn.microsoft.com/ru-ru/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#complex-segments`).

Каждый сегмент либо литеральный (`product\`), либо параметр (`{id}`). Литеральные сегменты не чувствительны к регистру.

Значения параметров фиксируются и их можно получить в обработчике конечной точки.

* {id} - обязательный сегмент;

* {name=all} - необязательный сегмент со значением по умолчанию;

* {filter?} - просто необязательный сегмент;

**Необязательные параметры можно поставить только в конец шаблона. Все параметры до них (в т.ч. другие необязательные) должны быть заданы (прим. `/product/{category}/{name=all}/{id?})`, до `id` должны быть определены `name` и `all`**

Можно наложить ограничения на маршрут (больше информации на `https://learn.microsoft.com/ru-ru/aspnet/core/fundamentals/routing?view=aspnetcore-9.0#route-constraints`):

* `{qty:int}`, `{id:guid}`, `{age:min(18)}`, `{qty:int?}`, `{qty:int:max(10)}` и т.д.

**Не используйте ограничения маршрута для проверки общих вводимых данных. Это приведет к ошибке NotFound для пользователя, что введёт его в заблуждение.**

Вышеприведенные параметры не были жадными (захватывали минимум для себя).

Также есть универсальные параметры, которые являются жадными (с одной или двумя `*`) и захватывают всё. Для входящих запрос ведут себя одинаково. Различается поведение только при генерации URL-адресов.

Пример: `/{currency}/convert/{**others}`

Соответсвуют:

* `/USD/convert/GBP`

* `/USD/convert/GBP/EUR`

* `/USD/convert/GBP/EUR/CAD`

**Генерация URL-адресов из параметров маршрута**

Универсальные жадные параметры с одной звёздочкой экранирует косую черту, а с двумя звёздочками не экранирует. Обычно используется версия с двумя звёздочками.

В минимальных API можно использовать `LinkGenerator`.

Пример:

`app.MapGet("/product/{name}", ...).WithName("product");`

`app.MapGet("/links", (LinkGenerator links => link.GetPathByName("product", new { name = "big-widget" }))`

`WithName()` добавил метаданные к конечной точке. Имена конечных точек чувствительны к регистру и должны быть уникальны.

`LinkGenerator.GetUriByName` для генерации полного пути. Хост для метода обычно берут из `HttpContext`. Если нет ограничений по `allowedHost`, то возможны уязвимости.

`LinkGenerator` автоматически по названию параметров маршрута понимает, куда их нужно подставить.

Также можно использовать `app.Map("...", () => Results.RedirectToRoute("endpoint_name"));`. По умолчанию генерирует `StatusCode 302 Found` и включает сгенерированный адресс в заголовок ответа `Location`. Может привести к такому поведению (`302`), что браузер будет сразу перенаправлять новые запросы на этот адрес, даже не загружая исходный. Следует быть осторожным. Соответсвующая статья: `https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status#redirection_messages`.

`Results.Redirect()` используется для перенаправления на заданный URL.

`WebApplication build.Services.Configure<RouteOptions>(o => ...)` для конфигурации генерации URL адресов (напр. чтобы были в нижнем регистре). При необходимости можно переоперделить при вызове конкретного метода генерации.

### Задания

1. Создать небольшое приложения "конвертации" валют. Пусть основная конечная точка будут как в примере из книги для универсальных параметров конечной точки курсов валют. Но при этом добавь ещё одну точку для просмотра курсов валют по пути `{from}/rate/{to}`, но при этом они должны перенаправляться на `http://sberbank.ru/ru/quotes/currencies?tab=sbol&currency={currency}&currency={newCurrency}`.

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%206/Exercise%201/AppBuilder.cs`. В процессе чтения и реализации ещё раз напомнил себе систему маршрутизации ASP.NET Core.

## Глава 7. Привязка модели и валидация в минимальных API.

**Привязка модели - механизм извлекающий значения из запроса и использующий их для создания объекта .NET. Затем он передает эти объекты в метод обработчик конечной точки**.

Выполняется односторонняя привязка.

`EndpointMiddleware` выполняет преобразование строк параметров в объекты модели.

Минимальные api могут использовать следующие источники привязки для аргументов:

* значения маршрута (сегменты и значения параметров по умолчанию)

* значения строки запроса

* значения заголовков

* тело JSON

* сервисы внедрения зависимостей

* собственная привязка через HttpRequest

**В minimal-api не работает автоматическая привязка к `application/x-www-form-urlencoded`, только тело запроса JSON. Но можно получить доступ через `HttpRequest.Form`.

Сначала пытается привязать параметр к параметру, указанному в шаблоне маршрута. Если не смог, то попытается найти нужный в строке запроса.

Аттрибуты на параметрах в методе обработки конечной точки `[FromRoute]`, `[RromQuery]`, `[FromHeader]`, `[FromBody]`, `[FromServices]` явно указывают, откуда взять значения параметров. Первые три из них позволяют выполнить привязку к простым типам (`int`, `double`).

**Простой тип - тип, реализующий TryParse метод. Можно реализовать свой простой тип (IParsable, либо статические методы TryParse с подходящей сигнатурой).

**Если попытаться связать несовместимые типы, то ASP.NET Core выдаст исключение BadHttpRequestException и вернёт ответ 404 Bad Request.

Для minimal-api нельзя заменить библиотеку сериализации `System.Text.Json` (при привязках к телу запроса или записи в тело ответа), можно только настроить некоторые параметры.

Если формат тела запроса отличается от JSON, то обработчик конечной точки не запуститься, а `EndpointMiddleware` вернет ответ `415 Unsopported Media Type`.

Если попытаться привзять тело HTTP-метода, у которого обычно нет тела (`GET`, `HEAD`, `OPTIONS`, `DELETE`, `TRACE`, `CONNECT`), то получите исключение `InvalidOperationException` во время выполнения. Можно обойти это ограничение, используя на параметре атрибут `[FromBody]`, но не рекомендуется это делать, т.к. это поведение не соотвествует `RFC9110`.

**Можно привязать массив к параметру метода (или к `[FromRoute]`), например из строки запроса.** Напр. `products?id=123&id=456`. `app.MapGet("/products", ([FromQuery]int[] id ) => {...});`. Подходят любые простые типы, `string[]` и `StringValues`.  ASP.NET Core автоматом (без аттрибута) привязывает массив к строке запроса если запрос `GET`. `HEAD` или `DELETE` и массив представляет собой массивы простых типов. В ином случае пытается привязать к телу.

Все параметры по умолчанию обязательные.

Если `app.MapGet("/products/{id?}", (int  id) => {...});` и отправить запрос по `/products`, то это вызовет ошибку `BadHttpRequestException` и вернёт `400 Bad Request`. Можно избежать отметить параметр допускающим `null` (`int? id`). Аналогично для сложных типов.

В минимальных API можно получить доступ из обработчика (передав в качестве параметров) также следующие типы:

* `HttpContext` - все сведения и о запросе, и об ответе;

* `HttpRequest` - эквивалент `HttpContext.Request`;

* `HttpResponse` - эвивалент `HttpContext.Response`;

* `CancellationToken` - эквивалент `HttpContext.RequestAborted`. Токен срабатывает, если клиент прерывает запрос (полезно для задач с длительным временем выполнения). Подробнее `https://andrewlock.net/using-cancellationtokens-in-asp-net-core-minimal-apis/`;

* `ClaimsPrincipal` - эквивалент `HttpContext.User`. Содержит данные аутентифкации пользователя;

* `Stream` - эквивалент `HttpRequest.Body`. Полезен, когда необходимо обрабатывать большие объёмы данных из запроса, не удерживая их все в памяти одновременно;

* `PipeReader` - эквивалент `HttpContext.BodyReader`. Полее высокоуровневый API по сравнению с `Stream`, полезен в аналогинчых ситуациях. Пространство имен `System.IO.Pipelines`.  Подробнее `https://learn.microsoft.com/ru-ru/dotnet/standard/io/pipelines`;

* Зарегистрированные в контейнере `DI` сервисы. Можно принудительно пометить атрибутом `[FromServices]` (например при использовании своего контейнера `DI`).

**Загрузка файлов**

> **Загрузка файлов потенциально опасное действие. Не стоит доверять указанному имени файла, нужно быть осторожным с загружаемыми большими файлами и не позволять файлам выполняться на сервере. Также вопрос где и как хранить файлы (БД, файловая система, S3 и т.д.). Лучше избегать загрузки файлов пользователями без крайней необходимости, а к самими загружаемым файлам относится с осторожностью как к потенциальному вредоносу.**

Загрузка файлов выполняется через интерфейсы `IFormFile` и `IFormFileCollection`.

> Эти интерфейсы могут предоставлять свойство `string FileName`. **Никогда не стоит использовать предоставленное имя файла в коде. Это может привести к атаке на веб приложение и доступа к файлам, к которым пользователям не следует иметь доступ. Всегда создавайте новое имя для файла, прежде чем сохранять его где-либо!**

Данные интерфейсы подходят для небольших файлов, т.к. всё содержимое файла буферизируется в памяти и на диске перед его получением. Для больших файлов следует использовать потоковую передачу данных `https://learn.microsoft.com/ru-ru/aspnet/core/mvc/models/file-uploads?view=aspnetcore-9.0#upload-large-files-with-streaming`.

**Привзяки модели**

Для своей кастомной логики привязки модели можно реализовать статический интерфейс `IBindableFromHttpContext` или статический методы `public static ValueTask<T?> BindAsync(HttpContext context)` или `public static ValueTask<T?> BindAsync(HttpContext context, ParameterInfo parameter)`. Если не спарсить данные, то стоит вернуть `null`.

Порядок выбора источника привязки в minimal-api к параметру:

1. Через атрибут `[From*]`;

2. Если тип парпаметра общеизвестный тип, напр. `HttpContext`, `HttpRequest`, `Stream`, `IFormFile`;

3. Если тип параметра имеет метод `BindAsync`;

4. Если строка или имеет `TryParse()`:
    a. к параметру маршрута если совпадает с именем параметра в маршруте;
    b. к строке запроса.

5. Если параметр массив простых типов, массив строк или `StringValues`, а сам запрос представляет метод, который обычно не имеет тела (напр. `Get`).

6. Если есть в `DI`, то из `DI`.

7. Привязка к телу десериализацией из JSON.

**Для упрощения модели привязки (куча параметров метода обработчика, атрибуты) можно использовать атрибут `[AsParameters]`, который указывает, что аргументы и параметры объеденины в один отдельный класс.**

**Обработка пользовательского ввода путем валидации модели**

В минимальном api не включаются отдельные механизмы валидации, используются обычно фильтры для реализации валидации и/или с атрибутами валидации (`DataAnnotations`), интерфейсами `IValidatableObject`. Об атрибутах валидации подробнее в: `https://learn.microsoft.com/ru-ru/dotnet/api/system.componentmodel.dataannotations?view=net-9.0`.

Можно использовать аналоги для валидации по типу `FluentValidation`.

Можно написать собственный фильтр для обработки валидации, а можно использовать `NuGet` пакет `MinimalApis.Extensions` и метод расширения `WithParameterValidation()`.

### Задания

1. Создать API для поиска товаров с основным поисковым запросом (строка текста с тем, что пользовательн хочет найти), категория (из маршрута), фильтры по цене, доступном кол-ве, тегам. Входные данные должны валидироваться, должны поддерживать множественные указания тегов. 

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%207/Exercise%201/AppBuilder.cs`. В процессе реализации задания обнаружил, что если передать 3 разных параметра `min-price` в строке запроса, то приложение генерирует `OverflowException`. Что-то странное происходит под капотом у ASP.NET Core. Поставлю в задания `Планы на потом` выяснить, чем вызвано это поведение (возможно из-за внешней библиотеки, подключающей валидацию к конечной точке).

### Задания

Глава слишком обзорная для заданий.

## Глава 8. Введение во внедрение зависимостей

> В ASP.NET Core встроено внедение зависимостей и полностью уйти от него сложно (но частично можно).

Граф зависимостей - набор объектов, которые нужно создать для получения определенного запрашиваемого "корневого" объекта.

Основная задумка - перемещение графа зависимостей объекта в его конструктор (или фабричный метод) и делегация их инициализации в сервис "контейнер внедрения зависимостей". Сами зависимости желательно передавать интерфейсами.

Преимущество - снижаем зависимость и связность объекта с используемыми им зависимосятми.

Минус (именно контейнера) - легко случайно скрыть бардак в графе зависимостей, а разрешаться это все будет только в рантайме = теряем преимущества статической типизации.

`RequestDelegateFactory` запрашивает экземеляры объектов для разрешения зависимостей у контейнера (для mininmal API).

В Razor Pages используются активаторы модели страницы, котоорые вызывают контейнер внедрения зависимостей.

### Задания

Глава слишком обзорная для заданий.

## Глава 9. Регистрация сервисов с помощью внедрения зависимостей

Базовый DI контейнер ASP.NET Core использует некую оптимизированную рефлексию.2

Для регистрации `WebApplicationBuilder.Services.Add...`.

Для получения из контейнера вручную используются `WebApplicationBuilder.Services.GetService<T>()ж и .GetRequiredService<T>();` (паттерн Локатор сервисов).

Для регистрации открытых обобщенных типов используется конструкция такого вида: `services.AddScoped(typeof(IRepository<>), typeof(DbRepository<>));`.

Если зарегистрировано несколько реализаций для одного интерфейса и объект вызывает только один интерфейс (не `IEnumerable`), то внедряется последний зарегистрированный в DI (так можно например заменять уже зарегистрированные сервисы).

Для регистрации если для данного сервиса ещё нет реализаций можно использовать `buider.Services.TryAdd...` методы.

Для замены уже зарегистрированных обработчиков сервиса можно использовать `builder.Services.Replace(new ServiceDescriptor(typeof(IMessageSender), typeof(SmsSender), ServiceLifetime.Scoped));`. Жизенный цикл должен быть указан тот-же, что уже использовался.

Жизненый цикл типа в DI контейнере ASP.NET Core:

* Transient - создает новый экземпляр сервиса при каждом его запросе;

* Scoped - в пределах **области применения** все запросы сервиса будут предоставлять один тот-же объект. Для разных - разные. В ASP.NET Core каждый запрос получает свою область применения;

* Singleton - всегда один и тот же экземпляр. **Все такие сервисы должны быть потокобезопасны!**

Если сервис реализует IDisposable, то DI контейнер при Transient, Scoped автоматически освобождает ресурсы когда область действия заканчивается.

**ЛОВУШКА**. Если зарегистрировать два сервиса напр. `DataContext` и `Repository`. При этом `Repository` требует для создания себя `DataContext`. И при этом `DataContext`scoped, а `Repository` singleton. Это всё создатс захваченную зависимость, при которой у нас всегда будет один `DataContext`, т.к. он внедряется в singleton (и соотвественно не высвобождается и не заменяется).

**Сервис должен использовать только те зависимости, жизненный цикл которых превышает или эквивалентен жизненному циклу сервиса.**

ASP.NET Core автоматически должен проверять в runtime такие проблемы и выбрасывать исключение. **По умолчанию такая проверка активируется только в окружении разработки (ValidateScopes, ValidateOnBuild).**

Проблемы, которые не может автоматом отловить контейнер DI и ASP.NET Core: `https://andrewlock.net/new-in-asp-net-core-3-service-provider-validation/`.

**Запрос сервисов scoped и transient напрямую из контейнера может привести к утечке памяти, посколько объекты остаются активными и не подвергаются сборке мусора до конца работы приложения.**

Создание своей области применения: `await (using var scope = app.Services.CreateAsyncScope()) {var service = scope.ServiceProvider.GetRequiredService<DataContext>() }`.

### Задания

1). Проверить, что будет, если зарегистрировать для одного и того-же сервиса реализации с разным жизненным циклом. То-же самое для `TryAdd...` и `Replace` методов. Изучить ValidateScopes, ValidateOnBuild поведения при данной ситуации.

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%209/Exercise%201/AppBuilder.cs`.
    В ходе экспериментов выяснил, что срабатывает последняя добавленная реализация сервиса НЕЗАВИСИМО от жизненного цикла предыдущей реализации. `Replace` добавляет новую реализацию с указанным `ServiceLifetime` если её не было ранее, и добавляет в конец списка реализация сервиса (т.е. она будет вызвана). `TryAdd` напротив, при попытке добавить с любым `ServiceLifetime`, если уже есть какая-либо (не важен `ServiceLifetime`) реализация не добавит (т.е. уже есть с `ServiceLifetime.Scoped`, пытаемся добавить новую с `ServiceLifetime.Singleton` и она не будет добавлена).

## Глава 10. Конфигурация приложения ASP.Net Core

ASP.NET Core использует поставщиков конфигурации для загрузки пар "ключ-значение" из множества источников.

`IConfigurationBuilder` - для постройки представления конфигурации.

`IConfigurationRoot` - представляет значения конфигурации. 

`IConfigurationProvider` - является поставщиком конфигурации.

Каждый новый поставщик может переопределить значения, заданные предыдущим.

**Ключи конфигурации в приложении ASP.NET Core НЕ ЧУВСТВИТЕЛЬНЫ К РЕГИСТРУ**

По умолчанию `WebApplicationBuilder` добавляет по умолчанию следущих поставщиков:

* постащик файлов JSON (appsettings.json, appsettings.ENVIRONMENT.json);

* пользовательсие секреты - загружает секреты;

* переменные окружения - загружает переменные окружения в качестве переменных конфигурации;

* аргументы командной строки - значения, переданные в качестве аргументов при запуске приложения.

Очистка поставщиков конфигурации `builder.Configuration.Sources.Clear()`.

**Значения конфигурации добавляются сразу, до вызода `Build`.**

Для безопасного хранения конфиденциальных данных обычно используют `User Secrets` локально и переменные окружения на рабочем сервере.

**Крайне не рекомендуется конфиденциальные данные в системе управления версиями.**

Можно использовать префикс для переменных окружения, чтобы избежать коллизий. Для этого применяется `AddEnvironmentVariables("SomePrefix")`. Префикс удаляется из ключа перед его добавлением в `ConfigurationManager`.

**Рекомендуется использовать пользовательские секреты только в окружении разработчика.**

Предпочтительным способом использование настроек конифигурации является их отображение на модель (POCO). Для этого удобно внедрять в обработчик конечной точки `IOptions<AppDisplaySettings> options`. Связка: `builder.Services.Configure<AppDisplaySettings>(builder.Configuration.GetSection("AppDisplaySettings"));`.

Каждый вызов `Configute<T>`:

* Создает экземпляр `ConfigureOptions<T>`, который указывает способ настройки `IOptions<T>`. **Если вызываются несколько раз `Configure<T>`, то будут применяться несколько `ConfigureOptions<T>`, которые могут настроить разные части объекта например**.

* Каждый экземпляр `ConfigureOptions<T>` привязывает секцию `IConfiguration` к экземпляру класса POCO.

* Интерфейс `IOptions<T> регистрируется в контейнере DI как Singleton с последним связанным объектом POCO в свойстве Value **И БОЛЬШЕ НЕ ОБНОВЛЯЕТСЯ**.

`IOptionsSnapshot<T>` - аналог `IOptions<T>`, который при необходимости создает новый экземпляр, если с момента создания базовая конфигурация изменилась. **Регистрируется как Scoped сервис.** Для использования в Singleton сервисах можно использовать `IOptionsMonitor<T>`: `https://andrewlock.net/creating-singleton-named-options-with-ioptionsmonitor/`.

**Можно валидировать связку POCO объектов с конфигурацией. ** `https://andrewlock.net/adding-validation-to-strongly-typed-configuration-objects-in-dotnet-6/`.

Можно использовать `Bind` для привязки и добавления в `DI`.

Для проверки текущего окружения размещения и контекста запуска приложения используется `WebAppliction.Environmet`, что является `IHostEnvironment`.

> Команда для запуска приложения с определенным профилем: `dotent run --launch-profile <Profile Name>` (по умполчанию первый профиль в `launchSettings.json`). 
Если хотим без профиля, то `dotnet run --nu-lauch-pfofile`.

### Задания

1. Опробовать `IOptionsSnapshot`, `IOptionsMonitor` в сочетании с json конфигурацией.

    **Решение**
    Реализовал по сслыке: `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2010/Exercise%201/AppBuilder.cs`.
    Опробовал как работают данные интерфейсы с Singleton сервисом и просто с endpoint-ами. Закрепил изученное в главе.

## Глава 11. Документирование API с помощью OpenAPI

OpenAPI (ранее Swagger) - спецификация для описания RESTful API.

Две основные библиотеки: `Swashbucle` и `NSwag`.

Использование:

`builder.Services.AddEndpointsApiExplorer();`
`builder.Services.AddSwaggerGen();`
если `CreateEmptyBuilder` или `CreateSlimBuilder` - `builder.Services.Configure<RouteOptions>(opt => opt.SetParameterPolicy<RegexInlineRouteConstraint>("regex"));`
`app.UseSwagger();`
`app.UseSwaggerUI();`

Для изменения значений документа можно использовать `builder.Services.AddSwaggerGen(x => x.SwaggerDoc("v1", new OpenApiInfo() => ...));`

**Можно использовать группировку маршрутов для применения метаданных.**

`NSwag` позвоялет создать клиента C# по OpenAPI.

При генерации через VS и настройке генерации через подключенные службы и .csproj обновление сгенерированного кода наступает при изменении именно json файле OpenApi, который он сохряняет в проекте) Т.к. изменении конфигурации генерации в .csproj ему по барабану, как и ребилд, даже с очисткой. По хорошему нужно удалять сразу всю obj папку. Либо внести небольшое изменение в JSON файл OpenAPI, сгенерировать клиента, потом откатить и снова сгенерировать. Ну а чем, разрабам инструмента видимо удобно.

Полезный тег `WithName`, которое устанавливает `operationId` в спецификации и используется для генерации названий методов клиентов.

Можно использовать сводки и описания метаданных в генерации документа если установить `Microsoft.AspNetCore.OpenApi` и вызвать метод `WithOpenApi()` для коненой точки. И можно добавить теперь `WithSummary()` и `WithDescription()`.

Через методы нет элегантного способа добавить метаданные для параметров. Можно задать метаинформацию для OpenAPI через `WithOpenApi(operation => {...})` вместо использования методов.

Альтернативный способ задания метаданных через атрибуты:

* `[EndpointName("")]`

* `[EndpointSummary("")]`
* `[EndpointDescription("")]`
* `[ProducedResponseType(typeof(Product), 200)]`, `[ProducedResponseType(typeof(HttpValidationProblemDetails), 404, "application/problem+json")]`
*  `[Tags("Tag")]`

Также можно добавлять через XML комментарии, но как по мне способ не очень хороший, слишком много абстрактых конвенций.

**Не всё можно описать с помощью OpenAPI, например HATEOAS, т.к. для OpenAPI заранее требуется знать, какие есть конечные точки и ответы на них. Или например если у на с несколько серверных API с OpenAPI и шлюз (нет простого способа объеденить спецификации в одну). Также возникают проблемы связанные с аутентификацией и авторизацией, если используются расширения стандартных протоколов или вообще свои.**

> Очень часто с генерацией кода больше проблем чем пользы, поэтому лучше дважды подумать, нужно ли оно вообще или легче написать самому / сгенерить AI по нужному тебе шаблону.

> Впринципе не всегда стоит инвестировать в OpenAPI, т.к. если не нужна генерация клиентов или сложные требования к конечным точкам, то OpenAPI будет только мешать.

> Для кодогенерации при условии, что можно использовать удалыенный вызов процедур, рекомендуется gRPC и его кодогенераторы.

### Задания

1. Отработать основные инструменты главы на каком-нибудь API из выполненных заданий прошлых уроков.

    **Решение**
    Использовал OpenAPI спецификацию, SwaggerUI, NSwag кодогенерацию в консольном клиенте.
    Реализовал по сслыкам: 
    `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2011/Exercise%201/AppBuilder.cs`
    `https://github.com/nekix/Education/blob/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore.ConsoleClient/Chapter%2011/Exercise%201/ApiService.cs`


## Глава 12. Сохранение данных с Entity Framework Core

ORM - object relationship mapping.

Основно преимущество - скорость разработки и легкость входа для простых случаев (ключевое слово - простых).
Основные минусы - привязка развития схем БД к приложению, меньший и более сложный контроль (гибкость) за запросами.

Процесс добавление EF Core состоит из следующих этапов:

1. Определиться с провайдером базы данных (Postgresql, SQLite и т.д.);

2. Установить пакеты NuGet для EF Core;

3. Спроектировать DbContext;

4. Зарегистрировать DbContext в DI контейнере;

5. Использовать EF Core для создания миграции, описывающей модель данных (если Code first);

6. Применить миграцию к БД для обновления схемы.

Типичная схема использования

DbContext - MapToPoco -> Service(or Repository) - MapToDomainModel or MapToViewModel -> ... -> Endpoint

Для миграций можно использовть бандл для упрощения применения миграций в промышленном окружении `https://learn.microsoft.com/ru-ru/ef/core/managing-schemas/migrations/applying?tabs=dotnet-core-cli#bundles`.

**Всегда учитываем вероятность SQL инъекций и не вставляем пользовательский ввод в SQL инструкции напрямую. Используем параметризированные команды, хранимые процедуры/функции.**

EF Core по умолчанию регистрирует все выполняемые инструкции SQL как события LogLevel.Information. Включив вывыод данного уровня удобно проверять, какие инструкции генерируются и отправляются.

Для реализации мягкого удаления удобно использовать глобальные фильтры запросов: `https://learn.microsoft.com/ru-ru/ef/core/querying/filters`.

Сложности:

1. Если несколько веб-хостов на одну БД (кто отвечает за схему БД и миграции, как контролируем?);

2. Обратно совместимые изменения БД;

3. Инициализация БД данными;

4. Способ примененяи миграций (ручное, CI/CD?).

### Задания

1. Посмотреть какие есть аналоги EF Core (напр. ADO.NET, Dapper).

    **Решение**
    
    1. NHibernate - тоже ORM. Как минимум раньше был более гибким при реализации DDD подходов;
    
    2. Dapper - OM (без R), впринципе этим все сказано. Всегда славился производительностью. Также удобно использовать с хранимыми процедурами.
    
    3. LINQ to DB - что-то среднее между Dapper и EF Core. Уже позволяет вместо SQL писать LINQ выражения (этим и выше на ступеньку Dapper-а).
    
    4. Insight.Database - Маленькая и простая в использовании micro-ORM. Автоматом сопоставляет Процедуры, таблицы.
    
    5. ADO.NET - библиотека, обеспечивающая обычно самый низкоуровневый доступ к данным, который может понадобиться в типовых программах. Поддерживает не только реалиационные базы данных, но и другие источники. Предоставляет мощные и обычно исчерпывающие абстракции.


## Глава 13. Создание сайта с помощью Razor Pages.

Можно переопределить стандартные пути внутри проекта к:

* Razor pages: `.WithRazorPagesRoot("newRelativePath")`;
* статическим файлам: `UseStaticFiles(new StaticFileOptions {...})`;

Система маршрутизации обычно сопоставляет пути URL запросов с одной URL страницей. Путь строится относительно тех папок, в которых лежит Razor pages страница (начиная по умолчанию с папки Pages).

Обработчики страниц именуются по соглашению на основе Http метода `On...`. Напр. `OnGet()`, `OnPost()`. Возвращают `void` для отрисовки страницы, либо `IActionResult` для прочих инструкций.

MVC наше всё (учитывая что и Razor Pages поверх него работают).

### Задания

1. Перенести и адаптировать базовую конфигурацию WebAppication под структуру папок в нашем решении (далее эта папка будет использоваться для заданий последующий глав).

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`

## Глава 14. Сопоставление URL-адресов с Razor Pages с использованием маршрутизации.

Три подхода к маршрутизации:

* глобальная - на основе соглашений, настраивается централизованно, используется для всех конечных точек. `https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0`;

* явная - каждая конечная точка с отдельным шаблоном маршрута (атрибуты `Route` на самих методах действия);

* гибридный подход (используется в Razor pages). Соглашение на основе относительных путей папок, возможность ручной настройки или донастройки.

Шаблоны маршрута конкретной страницы определяются в директиве `@page`. Если шаблон маршрута начинается с `\`, то он заменяет маршрут полностью, иначе дополняет.

`Url` представляет `IUriHelper`, обертку над `LinkGenerator`, которая позволяет генерировать относительны маршруты к страницам. `Uri.Page` для Razor Pages, `Uri.Action` для контроллеров MVC. **ПОМНИМ ПО ALLOWED HOSTS и уязвимость с генерацией другого адреса**. `IUriHelper` проще в использовании, но доступен только в методах обработчиках страниц, а `LinkGenerator` доступен везде, где вы его внедрите.

Для настройки соглашений, стиля, вида Url адресов можно использовать `builder.services.Configure<RouteOptions>(o =>  { ... });`. Для настройки например дефисов вместо написания с больщой буквы следует использовать свой преобразователь параметров. Он реализует интерфейс `IOutboundParameterTransformer`. После его можно зарегистрировать в `builder.Services.AddRazorPages().AddRazorPagesOptions(opts => {opts.Conventions.Add(new PageRouteTransformerConvention(new MyCustomTransformer))});`. Там же можно зарегистрировать альтернативные маршруты для заданной стараницы: `opts.Conventions.AddPageRoute(...);`. Если нужен ещё больший контроль, то можно реализовать и зарегистрировать свой `IPageRouteModelConvention`, `IPageRouteApplicationModelConvention`, `IPageHandlerModelConvention`. Так можно например реализовать локализацию страниц `https://learn.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions?view=aspnetcore-9.0`.

### Задания

1. Добавить в сконфигурированный в прошлом уроке проект маршрутизацию, в т.ч. добавить в UI ссылки с помощью `IUriHelper`. Реализовать приведение маршрутов к нижнему регистру с чертой в конце и KebabCase написанием.

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`
    
## Глава 15. Создание ответов с помощью обработчиков страниц Razor Pages.

При выборе конкретного обработчика `EndpointMiddleware` выбирает на основе:

* HTTP-метод, используемый в запросе (например GET, POST или DELETE);

* значение обработчика (переменная `handler`) в маршруте.

`On{verb}{hanlder}{Async}`, где `verb` - HTTP глагол, `handler` - значение обработчика, `Async` - необязательный суффикс.

**Если получен запрос, которому нет обработчиков на странице, то выполняется неявный обработчик (как если бы он был, но возвращал пустое представление). Есть одно ислючение: `HEAD` если нет соответвующего `OnHead()` выполнит `OnGet()`. Также нельзя выполнять перегрузку методов, чтобы было несколько обработчиков одного имени.**

Razor Pages помимо привязки значений запроса к параметру обработчика может также привязывать их к свойство отмеченному атрибутом `BindProperty[]` (для `GET` запросов по умолчанию не заполняется).

Самые частые ответы `Page()` и `RedirectToPage()`.

**Для передачи данных между запросами можно использовать `TempData`: `https://learn.microsoft.com/ru-ru/aspnet/core/fundamentals/app-state?view=aspnetcore-9.0#tempdata`.**

Для обработки ошибок по типу NotFound status сode можно использовать `app.UseStatusCodePages()` или (что лучше) `app.UseStatusCodePagesWithReExecute("/{0}")` и, где `{0}` - маркер строки форматирования пути в зависимости от статус кода (404, 500 и т.д.). Также можно использовать `app.UseStatusCodePagesWithRedirects("/{0}")` для именно перенаправления на страницу ошибок. `https://andrewlock.net/re-execute-the-middleware-pipeline-with-the-statuscodepages-middleware-to-create-custom-error-pages/`

`StatusCodePagesMiddleware` имеет и другие варинты перегрузок, позволяющие запускать настраиваемые компоненты при возникновении ошибки вместо повторного выполнения конвеера.

### Задания

1. Добавить в сконфигурированный в прошлом уроке проект маршруты и обработчики для разных `handler`. Добавить проверку валидности модели `ModelState.IsValid` для какого-нибудь поискового запроса. Добавить обработку ошибочных статус кодов (перенаправление на стандартный `/Error` маршрут разработки).

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`


## Глава 16. Привязка и валидация запросов с помощью Razor Pages.

Используемые Razor Pages модели:

* модель привязки - предоставленная пользователем информация о запросе + контекстные данные. Сама модель чаще всего определяемые разработчиком объекты POCO. Через `[BindProperty]` или параметры обработчика;

* модель приложения - фактически концепция. Набор классов, сервисов для исполнения бизнес-процесса приложения;

* модель страницы - (PageModel) выступает как контроллер (MVC) и как модель представления (.cshtml).

Один из неплохих вариантов компоновки модели привязки - вложенный в модель страницы класс входящих данных (как вариант, `InputModel` наименование).

По умолчнаню ASP.NET Core использует три разных источника привязки при создании модели привязки:

* значения формы - отправляются в теле HTTP-запроса, когда форма отправляется на сервер, с помощью метода POST;

* значения маршрута - получаются из сегментов URL-адреса или значений по умолчанию после сопоставления маршрута;

* значения строки запроса - передаются в конце URL-адреса, не используются во время маршрутизации.

Связыватель модели проверяет каждый источник привязки (если не конкретизировано). Если есть подходящее значение, то оно привязывается к свойству и валидируется. **В Razor Pages разные свойства сложной модели можно привязывать к разным источникам. Это отличается от модели MinimalApi, где частичная привязка не возможна. Также страницы Razor автоматически привязываются к телам форм, тогда как MinimalApi не могут этого сделать.**

Порядок проверки источников:

* Значения форм;

* Значения маршрута;

* Значения строки запроса.

Три способа привязки модели:

* декорировать свойства модели страницы атрибутом `[BindProperty]` - дает доступ к модели привязки при визуализации представления, удобно использовать для форм;

* добавить параметры в свой метод обработчика страницы - позволяет чётче разделить ответсвенность между обработчиками, но необходимо вручную скопировать параметры в свойства для отображения в представлении. Удобно использовать для простых страниц (и особенно методов Get);

* декорировать всю модель страницы атрибутом `[BindProperty]`.

**Если ни один из источников не содержит значения параметра (в т.ч. о умолчанию), то создаются либо `default<T>` для типов значений, либо объект через конструктор по умолчанию (без параметров), либо null (а если тип значения допускает null, то тоже null). Также по умолчанию связыватель модели не чувствителен к регистру.**

** Для привязки используются примитивные типы .NET, любой пользовательский тип, у которого есть метод `TryParse` или  преобразователь типов (из строки) `TypeConverter`. Что касается модели, то связыватель может  может связывать сложные типы, просматривая любые свойства, предоставляемые моделями привязки, и привязывая каждое из этих свойств к строкам.**

**Связыватель модели создает класс модели вызывая конструктор по умолчанию, а уже потом пытается заполнить свойства. Это можно использовать для задания значений по умолчанию и более типизированной валидации.**

**Связыватель может также искать свойства для сложной модели добавляя префикс с названием свойства самой сложной модели (напр. `user.FirsName` для `public UserBindingModel User { get; set; }` с `public string FirstName { get; set; }` свойством.

Списки можно задавать тремя способами:

* `currencies[0]=GBP&currencies[1]=USD`;

* `[0]=GBP&[1]=USD` (если привязка только к одному списку);

* `currencies=GBP&currencies=USD`;

Похожим образом можно к славарю.

Для привязки файлов пользователей используются `IFormFile` и `IFormFileCollection`.

Выбор источника привязки:

* `[FromHeader]`;

* `[FromBody]` - позволяет читать JSON;

* `[FromQuery]`;

* `[FromRoute]`;

* `[FromForm]`.

Доп. атрибуты:

* `[BindNever]` - пропустить привязку свойства;

* `[BindRequired]` - если параметр пуст либо не указан, то связыватель добавит ошибку валидации модели;

* `[FromServices]`;

* `[ModelBinder]` - поволяет задать множество параметров привязки.

**Валидация модели происходит после привязки модели но до обработчика страницы.**

В основном используются атрибуты `DataAnnotations`. Также можно использовать `IValidatableObject`.

Результаты валидации сохраняются в свойстве `ModelState`. При возврате страницы формы например с ошибками валидации обратно представление может автоматически получить ошибки валидации из `ModelState`.

Советы по организации страницы Razor:

1. Порядок: сервисы, конструктор, свойство модели привязки, обработчики, класс модели привязки (вложенный класс модели страницы);

2. Для Get обработчиков, особенно если передается какой-нибудь Id, передать его параметром в метод обработчик;

3. Проверять валидность модели (`if (!ModelState.IsValid) return Page();`);

4. Для POST использовать POST-REDIRECT-GET (`RedirectToPage("Index");`);

5. Валидация модели привязки (`DataAnnotations`);

6. Использовать одно свойство, декорированное атрибутом `[BindProperty]`;

7. Не использовать `[BindProperties]` (overposting);

### Задания

1. Добавить в проект объект модели привязки с валидацией. Добавить валидацию модели.

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`
    
 
## Глава 17. Отрисовка HTML кода с использование представлений Razor.
 
Можно изменить способ компиляции страниц Razor на динамический для быстроты отладки: `https://learn.microsoft.com/ru-ru/aspnet/core/mvc/views/view-compilation?view=aspnetcore-9.0&tabs=visual-studio`.
 
По синтаксису Razor выписываю в ** Короткая справка по синтаксису Razor**.
 
Доступ к общедоступным свойствам модели страницы можно получить через `@Model` объект в представлении.
 
Для задания значения в словаре `ViewData` можно использовать также атрибут `[ViewData]` на публичном свойстве модели.
 
**Хорошей практикой является создания глобального статического словаря констант, являющихся ключами для элементом словаря `ViewData`.**
 
**ViewData следует использовать, если значения должны быть использованы за пределами представления Razor. В иных случаях лучше использовать свойства модели.**.
 
**@inject не рекомендуется использовать по минимуму.**
 
**По умолчанию шаблоны Razor кодируют строки из выражений C# из соображений безопасности (нельзя просто так вставить HTML, внедрить вредоносные данные и JS код). Не стоит без весомой причины писать HTML код из выражений C (угроза безопасности).**
 
### Макеты

Общие элементы разметки выгодно извлекать в **макеты** (шаблоны). Их нельзя визуализировать напрямую, но можно включить их в состав обычных представлений Razor. Макеты чаще всего помещаются в папку `Pages/Shared`. Обычно к файлам макетов добавляют символ нижнего подчеркивания в начале `_`, чтобы отличать их от стандартнх шаблонов Razor в папке Pages. Размещение шаблонов в папке `Pages/Shared` по соглашению позволяет обращаться к ним по короткому имени без указания полного пути к файлу макета.

** `_Layout.cshtml` по соглашению является базовым макетом приложения.**

Макет должен вызывать функцию `@RenderBody()`. Она сообщает куда вставить содержимое из дочерних представлений. В макет обычно добавляются все ссылки на CSS и JS и общие элементы (footer, navbar...).

Представление может выбрать какой файл макета использовать задав `Layout = "_ExistedLayout";`.

Если необходимо визуализировать содержимое из дочерних представлений в нескольких местах макета, можно использовать **секции**. В представлении объявляются как `@section SectionName { ...section HTML... }`. Любой контент, не входящий в секции, будет отображен через `@RenderBody()`. Сама секция визуализируется в родительском макете с помощью директивы `@RenderSection("SectionName", required: true)`. Так например чаще всего представления добавляют нужные им скрипты `@section Script`. Макеты можно вкладывать друг в друга.

### Частичные представления

Извлекают общую разметку и позволяют использовать их в других представлениях. В них нет модели страницы и обработчиков, но при этом можно привязаться к данным в свойстве Model. Имена как и у макетов начинаются с нижнего подчеркивания.

```
@model ToDoItemViewModel
<h2>@Model.Title</h2>
<ul>
    @foreach (var task in Model.Tasks)
    {
        <li>@task</li>
    }
</ul>
```
Использование: `<partial name="_ToDo" model="todo" />`.

Если не указан абсолютный путь или расширение файла частичного представления, то движок ищет первое совпадение от папки текущего представления вверх то `Pages` и потом `Pages/Shared`, `Views/Shared`. При желании это поведение можно изменить `https://www.learnrazorpages.com/razor-pages/partial-pages#naming-and-locating-partial-pages`.

> Также можно использовать повсеместно AJAX с Razor Pages `https://www.learnrazorpages.com/razor-pages/ajax/partial-update`. Для этого рекоендуется активно использовать частичные представления.

### _ViewStart и _ViewImports

`_ViewImports` - содержит директивы, которые будут вставляться в верхнюю часть каждого представление Razor (в т.ч. частичных). Можно поместить в любую папку, будет применяться ко всем представлениям во вложенных папках.

`_ViewStart` - содержит общий для начала каждой страницы Razor Pages код. Выполняется до выполнения представления и только для представлений Razor Pages (не для макетов и частичных представлений). Также работает для вложенных папок.

### Задания

1. Добавить в проект вывод свойств модели в представление. Для этого подготовить страницу со списком товаров и с детализацией товаров. Для списка товаров использовать частичное представление для карточек товаров.

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`

## Глава 18. Создание форм с помощью тег-хелперов.

Тег-хелперы могут добавляться к стандартному элементу HTML (напр. `<input>`) для настройки его атрибутов на основе модели C#, либо быть автономными элементами и использоваться для генерации полностью настриваемого HTML-кода.

Являются логическим приемником HTML-хелперов. Воздействуют только на HTML (либо элемента на которые применены, либо на генерируемый собою HTML).

Улучшают читаемость другими редакторами кода при открытии HTML.

Чаще всего для генерации форм.

Активация одного тег хелпера (например на форме) делает доступными другие атрибуты.

Тег-хелпер формы создает скрытое поле `<input>` для защиты от CSRF.

Можно активировать валидацию на стороне клиента, если включить на странице библиотеки `jQuery`, `jQuery-validation`, `jQuery-validationunobtrusive`. Альтернатива - `aspnet-client-validation`. Также для шаблона по умолчанию на странице нужно включить `@section Scripts{ @Html.Partial("_ValidationScriptsPartial") }`.

Для раскрывающегося списка: `SelectListItem` и `asp-for` и `asp-items`. Есть также `Html.GetEnumSelectList<TEnum>()` чтобы не приводить список к `List<SelectListItem>` вручную. Также можно отображать группы в списках множественного выбора с помощью `<optgroup>`.

Можно добавить ошибку валидации, которая не относится к конкретному свойству: `ModelState.AddModelError(string.Empty, "Message");`. А потом можно вывести в сводку `asp-validation-summary`.

Для создание ссылки например в теге `<a></a>` можно использовать `asp-page` и `asp-page-handler`.

Для условий по Environment переменной окружения можно использовать следующую конструкцию (она выглядит органичнее просто условия через `@if`):

```
<environment include="Testing,Staging">
    <div class="warning">You are currently on a testing environment</div>
</environment>
```

### Задания

1. Создать форму обновления карточки товара. Применить валидацию на клиенте и сервере с помощью тег-хелперов. Заменить ссылки на товары с помощью тег-хелперов. Добавить предупреждение о нахождении в окружении разработки.

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`
    
## Глава 19. Создание сайта с использованием контроллеров MVC.

Контроллеры в MVC предназначены в основном для генерации HTML или JSON/XML.

Вместо PageModel и обработчиков страниц используются контроллеры и методы действия.

Обычно маршрутизация на основе соглашений, а не явная как в Razor Pages (напр. `"{controller=Home}/{action=Index}/{id?}"`.

Поиск представления для визуализации выполняется по имени представления (контроллера), параметрам. Если например контроллер называется `HomeController`, действие `Index`, то по умполчанию ищется `View/Home/Index.cshtml`. Если не нашел, то ищет в `View/Shared/Index.cshtml`. Алгоритм поиска можно изменить при желании.

Интересная статья о том, как MVC выполняет поиск контроллеров в представлении: `https://www.strathweb.com/2015/04/asp-net-mvc-6-discovers-controllers/`

Расположения View также можно поменять: `https://learn.microsoft.com/ru-ru/dotnet/api/microsoft.aspnetcore.mvc.razor.razorviewengineoptions.viewlocationformats?view=aspnetcore-3.1`

## Выбор между Razor Pages, MVC, Minimal API

### Плюсы Razor Pages

* В большинстве случаев страницы Razor pages менее раздуты чем контроллеры MVC;

* В MVC файлы группируются по типу (контроллеры, модели представления, представления), а в Razor Pages по функциям, все что связано с одной страницей размещается в папке этой страницы;

* Razor Pages лучше смотрится для содержательных веб-сайтов с преобладанием статических данных без реальной логики;

* Razor Pages оптимизирован для взаимодействия через формы;

### Плюсы MVC

* Если HTTP API, то это лучший выбор (без отрисовки представлений);

* Множество частичных обновлений страницы JS, AJAX, HTMX;

### Плюсы Minimal API

* При создании JSON API (или gRPC, GraphQL, SignalIR, RPC) предоставляет лучшую производительность;


### Задания

1. Добавить в проект поддержку MVC парараллельно с Razor Pages (в качестве MVC базовый шаблон взять, контроллеры, вью, модели).

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`


### Глава 20. Создание HTTP API с использованием контроллеров веб-API.

Структура расположения файлов жестко не задана (просто сканирует сборки на предмет наличия контроллеров). Конвеер примерно как в MVC. Вместо View используются **форматтеры вывода**.

Маршрутизация обрабатывается на основе атрибутов `Route()` и атрибутов действий по типу `HttpGet("fruit")`. Шаблоны от контроллера к действию складываются (если ниже не указан абсолютный маршрут `/path`). Также можно использовать подстановочные маркеры `[action]` и `[contoller]` в маршрутах. Также можно провернуть согласованные префиксы/шаблоны маршрутов через наследование через базовый класс контроллера с определенным шаблоном маршрута.

**Атрибут `[ApiController]`.** Подключает обязательную маршрутизацию на основе атрибутов. Автоматическая валидация модели и возврат 400-го кода ошибки. Автоматом добавляет `[FromBody]` к сложным типам в параметре метода обработки. Автоматом перехватывает любые статус коды, возвращаемые контроллером и преобразовывает их в тип `ProblemDetails`. При желании эти соглашению можно изменить в `ConfigureApiBehaviourOptions`. Подробнее про отключение: `https://learn.microsoft.com/ru-ru/aspnet/core/web-api/?view=aspnetcore-9.0`.

**Форматтеры вывода.** Процесс определения формата данных для отправки клиентам: **согласование содержимого**. Клиент указывает заголовок `Accept` с типами контента (и с весовыми коэффициентами если нужно, по умолчанию = 1, также можэет указзать кодировку символов). Сервер выбирает один из них (или выбирает свой) и отправляет в ответе `Content-Type`. **По умолчанию если не может удоволетворить `Accept` - возврат JSON**. `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/MIME_types`. RFC по согласованному содержимому: `https://www.rfc-editor.org/rfc/rfc9110.html#name-content-negotiation`.

За сериализацию данных отвечает `IOutputFormatter`. По умолчанию только для `text/plain`, `text/html`, `application/json`. Можно добавить новый, напр.: `services.AddControllers().AddXmlSerializerFormatters();`. Таким образом технически добавляется и форматтер ввода. `https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/custom-formatters?view=aspnetcore-9.0`.

**По умолчанию при возврате `null` возвращается `204 No Content. При возврате строки по умолчанию форматируется в `text/plain`. Если используется какой-либо другой класс, то по умолчанию первый форматтер, который может сгенерировать нужный ответ (JSON). Если промежуточное ПО обнаружит, что запрос вероятно исходит из браузера (`Accept` содержит `*/*`), то игнорирует заголовок и ответ будет отфармотирован форматтером по умолчанию.** Для изменения поведения можно использовать `buider.Services.AddControllers(options => { options.RespectBrowserAcceptHeader = true; options.OutputFormatters.RemoveType<StringOutputFormatter>(); });`.

Для точечной настройки: `https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting?view=aspnetcore-9.0#add-newtonsoftjson-based-json-format-support`.

**Контроллеры web-API vs Minimal API**

1. Если нужно возвращать данные в нескольких форматах, то выбираем контроллеры (если очень надо, то есть `https://andrewlock.net/adding-content-negotiation-to-minimal-apis-with-carter/` библиотека `Carter`).

2. Minimal API производительнее (если производительность очень сильно нужна взамен соглашений и удобства разработки больших API).

3. Если сложные требования к фильтрации, то лучше контроллеры. Иначе Minimal API.

4. В Minimal API вливается больше фич, поэтому предпочтительнее для новых проектов.

5. Разница подходов: controllers - соглашения; minimal api - явное объявление.

### Задания

1. Добавить в проект поддержку WebAPI парараллельно с MVC и Razor Pages (в качестве WebAPI базовый шаблон взять).

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`


## Глава 21-22. Конвеер фильтров MVC и Razor Pages. Создание собственных фильтров

Типы фильтров (и порядок их запуска):

1. фильтры авторизации - запускаются первыми в контейнере. Может прервать запрос и вернуть ответ. `IAuthorizationFilter`, `IAsyncAuthorizatonFilter`. 
Наиболее распространенный представитель: `AuthorizeFilter`.;

2. фильтры ресурсов - могут обрабатывать и входящий запрос, и исходящий ответ. Могут прервать запрос и вернуть ответ. `IResourceFilter` и `IAsyncResourceFilter`. 
Можно использовать для многих целей, т.к. вызывается достаточно рано. `ConsumesAttribute` - ограничивает число разрешенных форматов, которые может принять метод действия (в теле). `SkipStatusCodePagesAttribute` - предотавращает запуск компонента `StatusCodePagesMiddleware` для получения ответа (полезно когда одновременно и RazorPages и контроллеры). **Главное, что запускается до привязки модели**. **Можно использовать как переключатель функциональности `http://mng.bz/2e40`**;

3. фильтры действий для MVC, фильтры страниц для Razor Pages - запускается после привязки модели (до и после выполнения метода действия/обработчика страницы, а для Razor Pages также и после выбора обработчика страницы). Имеют доступ к аргументам метода действия. `IActionFilter` и `IAsyncActionFilter` или `IPageFilter` или `IAsyncPageFilter`. `ResponseCacheFilter` - включает кеширование на стороне клиента для запроса. **Рекомендуется наследоваться от `ActionFilterAttribute`**;

4. фильры исключений - могут перехватывать исключения и обрабатывать их. `IExceptionFilter` или `IAsyncExceptionFilter`. **ExceptionFilterAttribute**;

5. фильтры результатов - запускаются до и после выполнения метода действия IActionResult. Могут прервать выполнение. `IResultFilter` иди `IAsyncResultFilter`. **Есть нюансы с выполнением, использовать с осторожностью.** `ProducesAttribute` - сериализует результат веб-API в определенный выходнйой формат (в т.ч. игнорируя Accept заголовок клиента). `FormatFilterAttribute` - указывает искать значения магрута или параметр строки запроса format для определения выходного формата. **ResultFilterAttribute**.

Контроллеры тоже наследуют интерфейсы фильтров действия и их можно реализовать.

Способы применения фильтров:

1. Обычно реализуются как атрибуты. Следует реализовать либо синхронный, либо асинхронный интерфейс. **Если реализованы оба интерфейса, то выполняется асинхронный**;
    
    1.1 К методам действия;
    
    1.2 К контроллерам.

2. Глобально фильтры можно добавить через: `builder.Services.AddControllers(o => o.Filters.Add(new LogResourceFilter()))` или `builder.Services.RazorPages.AddMvcOptions(o => o.Filters.Add ... )`.

Порядок фильтров для нескольких фильтров одного типа (второй раз в обратном порядке, когда возвращает ответ):

1. Сначала глобальный фильтр;

2. Фильтр контроллера;

3. Фильтр базового (родительского контроллера);

4. Фильтр метода действия.

Для ручного контроля порядка выполнения фильтров можно использовать `IOrderedFilter` интерфейс. По умолчанию (даже если не реализует, то `Order=0`).

Отличия от промежуточного ПО:

1. Промежуточное ПО выполняется для всех запросов, а фильтры только для тех, которые доходят до компонента EndpointMiddleware и выполняются действие/страницу;

2. Фильтры имеют доступ к конструкциям MVC, таким как ModelState и IActionResult. А промежуточное ПО как правило нет;

3. Фильтры легко применить к подмножеству запросов. Промежуточное ПО не имеет такой концепции (но можно реализовать вручную).

**По факту, фильтры лучше использовать в крайнем случае, т.к. потенциально они только снижают читаемость flow кода. Старые добрые приватные методы явно лучше. И по сравнению с промежуточным ПО, лучше предпочитать промежуточное, если только не нужна более специфичная информация о контексе выполнения или ограничение области действия фильтра.**

### Задания

1. Добавить контроллер и фильтры как в данных глава в свой проект WebAPI.

    **Решение**
    `https://github.com/nekix/Education/tree/main/ASP.NET%20Core%20in%20Action/FrameworksEducation.AspNetCore/FrameworksEducation.AspNetCore/Chapter%2013`

## Глава 23. Аутентификация: добавление пользователей в приложение с помощью ASP.NET Core Identity.

Аутентификация - процесс определения пользовеля;

Авторазиция - процесс определения разрешений пользователя.

Текущий принципал запроса хранится в `HttpContext.User`. Принципалы реализованы в виде объектов ClaimPrincipal, у которых есть коллекция утверждений (Claim) (обычно пары ключ-значение), описывающих пользователя и состоящих из типа и необязательного значения.

Утверждения могут быть косвенно связанны с полномочиями и авторизацией (напр. свойствами `HasAdminAccess` или `IsVipCustomer`).

**Ранее использовался ролевой подход, сейчас следует использовать утверждения**.

Kestrel назначает принципала каждому запросу, поступающему в приложение (как минимум - анонимный принципал без аутентификации и утверждений).

Последовательность авторизации:

1. Клиент отправляет в приложение идентификатор и секрет;

2. Приложение проверяет соответсвие идентификатора и секрета;

3. Если верные, то приложение задает принципала для текущего запроса и выбирает способ его сохранения для последующих (напр. cookie, jwt-токен).

**Восстановление принципала из напр. cookie происходит в `AuthenticationMiddleware`.

ASP.NET Core Identity занимается хранением данных пользователя и управления ими в БД. Реализует большую часть шаблонного кода. `Microsoft.AspNetCore.Identity.UI` дает шаблонный код пользовательского интерфейса (но это Razor + Bootstrap).

Пользовательский интерфейс при желании можно переопределить с помощью скаффолдинга (генерация файлов в проекте, которые служат основной для настройки).


















## Короткая справка по синтаксису Razor (освежить в памяти)

`https://learn.microsoft.com/ru-ru/aspnet/core/mvc/views/razor?view=aspnetcore-9.0`

### Передача данных в представление:

* `@Model` - для доступа к модели страницы из шаблона;

* `ViewData` - словарь объектов для передачи произвольных данных (**в т.ч. в макеты**). Можно также использовать атрибут `[ViewData]` на публичном свойстве модели;

* `TempData` - аналог `ViewData`, но хранит данные до тех пор, пока они не будут прочитаны в другом запросе (обычно в зашифрованном Cookie). Используется для временно сохранения данных при использовании паттерна POST-REDIRECT-GET;

* `HttpContext`;

* `@inject` - внедрение зависимостей для доступа к сервисам из представления;

* `@Html.Raw(html)` - запись строки C# с html кодом напрямую в представление (небезопасно, особенно если пользовательский ввод).

### Общие конструкции

*`@DateTime.Now.Year` - выражение Razor. Конструкция для написания кода C# прямо в шаблонах Razor Pages. Вычисленное значение будет приведено к string и внедрено в шаблон. Пробел указывает окончание блока кода. Если нужно выполнения разделенных пробелом операторов, то необходимо взять в **круглые скобки**. **Если хотите написать литерал @, а не выражение C#, то можно написать @@.

* `@{ /* Здесь пишется код */ }` - блок кода Razor. Конструкция для написания кода C# прямо в шаблонах Razor Pages. Данный код будет выполнен, но не будет записан в ответ клиенту;

* `@ViewData["Title"]` - `@` записывает значение переменной C# прямо в HTML разметку и возвращет клиенту;

### Директивы (инструкция, изменяющая способ парсинга или компиляции шаблона)

* `@page` - указывает что файл относится к странице Razor. Размещается в начале файла. Через пробел добавляется шаблон маршрута: `@page "services/{serviceName}"`;

* `@model HomeModel` - указывает с какой моделью (классом) ассоциируется страница. Стандрартное соглашение наименованяи: `НазваниеСтраницыModel`;

* `@inject` - внедрение сервиса в представление;

* `@section Script` - определяет секцию в представлении, которая должна быть передана в макет.

### Функции

* `@RenderBody()` - указывает куда вставить содержимое дочерних представлений. Обязательно должна вызываться в макетах;

* `@RenderSection("SectionName", required: true)` - указывает куда и как вставить содержимое секции дочерних представлений;

* `@IsSectionDefined(sting section)` - true, если страница определила данную секцию (используется в макете);

* `@IgnoreSection(sting section)` - игнорирует невизуализированную секцию (используется в макете);

* `IgnoreBody()` - игнорирует невизуализированное тело страницы Razor (используется в макете).

### Тег-хелперы

* `<parial name="_ToDo" model="todo" />` - отрисовывает частичное представление;

* `asp-page` - добавляет к `form` `action` и `method` для отправки формы. Разблокирует другие атрибуты, например `asp-route-**`. Создает скрытое поле `<input>` **для предотвращения межсайтовой подделки запроса (CSRF)**;

* `asp-antiforegery="false"* - для отключения скрытого поля в форме;

* `asp-route-**` - напр. `asp-route-id` позволяет задать параметры маршрута отправки формы или генерации ссылки, в данном случае id;

* `asp-for="Input.Property"` - может применяться к `label`, `input`. Для метки использует атрибут `Display` в аннотациях данных или имя свойства, связывает с соответсвующими полями формы. Для `input` использует любые атрибуты `DataAnnotations` для определения типа элемента, добавления атрибутов валидции на стороне клиента `data-val-*`;

* `asp-format` - форматирование строки C# перед выводов в `input` (если есть `asp-for`). Альтернатива - атрибут `[DisplayFormat`];

* `asp-items` - для раскрывающихся списков.

* `asp-validation-for="Input.Property"` - указывает для какого свойства выводить сообщения валидации;

* `asp-validation-summary="All"` - указывает где вывести сводку по всем исключениям. None - не отображать, ModelOnly - только ошибки, не ассоцииорованные со свойством, All - ошибки, ассоциированные со свойством либо моделью;

* `asp-page` - генерация url в href;

* `asp-page-handler` - конкретизирует обработчик для `asp-page`;

* `asp-area` - указывает область действия маршрута;

* `asp-host` - ссылка будет указывать на предоставленный хост и генерировать абсолютный URL-адрес вместо относительного;

* `asp-protocol` - http или https ссылка. Если задан, то будет генериться абсолютный URL-адрес вместо относительного;

* `asp-append-version` - генерирует хеш на основе данных, который позволяет сбрасывать кеш при обновлении статического ресурса;

### Условные конструкции
```
@if (Model.IsComplete)
{
    <strong>Well done, you're all done!</strong>
}
else
{
    // ...
}
```

```
@foreach (var task in Model.Tasks)
{
    <li>@task</li>
}
```


## Планы на потом.
1. Вернуться к `HostFilteringMiddleware` `https://andrewlock.net/adding-host-filtering-to-kestrel-in-aspnetcore/` и атакам, от которых он защищает. Хотелось бы опробовать воспоизвести эти атаки.

2) Ознакомиться с введением в HTTP от Firefox `https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview`.

3) Пропустил введение интерфейсов IParsable. Изучить `https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/#static-abstracts-in-interfaces`.

4) Изучить что за новый для меня тип `StringValues` и зачем, где используется (глава 7).

5) Проблема нулевых ссылок, интересный материал (глава 7), ознакомиться: `https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/`.

6) Изучить и опробовать уязвимости, которые могут эксплуатировать злоумышленники при загрузке файлов через публичный API в приложение. Подробнее материал:  `https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload`.

7) Изучить и опробовать на практике уязвимости, которые закрывает валидация пользовательского ввода: `https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html`.

8) Глава 7. Задание 1. Выяснить, почему `OverflowException` возникает.

9) Глава 8. Статья про DI 2004 г. `https://www.martinfowler.com/articles/injection.html`. Также изучить разницу внедрения зависимостей и инверсии зависимостей (пост Дерика Бейли "Внедрение зависимостей НЕ тоже самое что и принцип инверсии зависимостей").

10) Глава 10. Продвинутые примеры использования `IOptions<T>`. `https://learn.microsoft.com/ru-ru/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0`. Посты по связаной теме в блоге `https://anrewlock.net`.

11). Изучить Azure Key Vault и Vault от Hashicorn `https://developer.hashicorp.com/vault`. (на машине без таких средств все ключи все равно храняться в открытом виде).

12) Посмотреть OpenAPI generator для создания клиентов по OpenAPI по сравнению с NSwag `https://github.com/OpenAPITools/openapi-generator`.

13) Изучить Partial Methods (source-generators) https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/partial-member

14) Вместе с REST посмотреть HATEOAS и уровни зрелости REST: https://martinfowler.com/articles/richardsonMaturityModel.html#level3

15) gRPC и кодогенерация.

16) Посмотреть scalar для документирования API.

17) Глава 12. Изучить информацию про проблему N + 1 для ORM.

18) Интересная страница с распространенными паттернами 'https://martinfowler.com/eaaCatalog/'

19) Изучить раздел 6-7 по работе с БД, данными, кешированием. Опробовать SQL иньекции. `https://professorweb.ru/my/ASP_NET/base/level1/base_aspnet_index.php`.

20) Изучить кодогенерацию. Напр. для регулярных выражений `https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/`. Логгирование `https://andrewlock.net/exploring-dotnet-6-part-8-improving-logging-performance-with-source-generators/`. Создание своих генераторов: `https://andrewlock.net/series/creating-a-source-generator/`.

21) Подробнее почитать о паттерне и его реализации POST-REDIRECT-GET.

22) Изучить вопрос overposting и `[BindProperties]` атрибута (Глава 16).

23) Вспомнить HTML хелперы (в данной книге они не рассматриваются, вместо них тег-хелперы).

24) Почитать об атаках с помощью оверпостинга `http://mng.bz/RXw0`

25) Посмотреть новые типы данных для `input` формы `https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input`.

26) Изучить области (Areas) MVC `http://mng.bz/3X64`.

27) Изучить дополнение к minimal api - Carter: `https://github.com/CarterCommunity/Carter`

28) Кеширование вывод методов действий: https://mng.bz/Bmlv

29) Документация по настройке Identity `https://learn.microsoft.com/ru-ru/aspnet/core/security/authentication/?view=aspnetcore-9.0`.