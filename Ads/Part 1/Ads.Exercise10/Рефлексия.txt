Задание 4 (+500). Декартово произведение множеств. 
Сам PowerSet<T> реализован так:
• базовая структура - массив списков (динамических массивов) List<T>[];
• каждый список соответствует элементам с одинаковым вычисленным на основе хеша индексом массива (то есть коллизиям);
• в списках хранятся сами элементы <T> в неупорядоченном виде.
В идеале, можно обобщить на произвольное число множеств (списком задаются).

Задание 6 (+500). Мульти-множество (Bag).
Реализовал на основе той же идеи, что заложил в PowerSet<T>, но с одним отличием: 
теперь элементами “списка коллизий” являются не элементы <T>, а связные списки 
LinkedList<T> одинаковых (внутри списка) элементов. Базовая структура: List<LinkedList<T»[].
Например, чтобы вставить элемент, необходимо получить хеш элемента, 
привести его к индексу в массиве списков и получить первый “список коллизий” 
(в коде slot). Внутри этого списка происходит перебор его элементов 
(списков одинаковых элементов для данной коллизии) в поиске того, 
в котором хранятся элементы с тем же значением что и у вставляемого 
(в коде equalItemsIndex). В найденный связный список вставляется элемент (в конец).

Попроще можно сделать, например, использовать готовый упорядоченный список. Я рассматривал этот вариант,
но в таком случае сложность операций вырастет до O(log N). Я постарался за счет более 
сложной структуры сохранить сложность близкой к O(1). Сложность операций будет O(D), 
где D "глубина" коллизии (максимальное число элементов, получивших из хеша один 
и тот же индекс в массиве), то есть при отсутствии коллизий O(1).
+ облегчается метод GetAll, для выполнения которого достаточно обойти массив 
и его коллизии. Сложность будет O(N + K), где N - размер Bag, K - число коллизий. 
В случае малого числа коллизий будет стремиться к O(N).
В данном случае я пожертвовал памятью, т.к. хранение всех этих массивов,
связных списков и ссылок (4 или 8 байта на ссылку, при например 4 
байтах на Int32) вызывает однозначное разрастание объемов и это минус. 
Также я не знаю насколько критично на низком уровне скажутся на 
производительности скачки от массива к массиву, которые могут 
располагаться в разных частях памяти.

На практике надо смотреть конкретную задачу, как там входные данные распределяются, и т.п. 