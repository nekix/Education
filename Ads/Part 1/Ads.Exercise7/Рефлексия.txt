Задание 8. Метод удаления дубликатов из упорядоченного списка.
Наверное лучше использовать готовый Delete.

Но я думал про удаление через delete, но он удаляет один элемент за раз, 
а я удаляю сразу "пачку" подряд идущих дубликатов, 
перезаписывая ссылки на следующие и предыдущие элементы для крайних элементов пачки. 
В таком случае получается меньше операций переприсваивания prev и next полей.
Если предпочтительнее очистить информацию в каждой исключаемой ноде о следующих 
и предыдущих, то я переделаю на реализацию через Delete.

Сделал через перегрузку метода Delete для поддержки множественного удаления. 

Задание 9. Слияние двух упорядоченных списков в один. 
В целях повышения эффективности реализовал через один проход по элементам обоих списков.

Задание 12. Поиск индекса элемента в списке за O(log N). При реализации принял, 
что самой “тяжелой” операцией является сравнение элементов <T>, т.к. заранее 
нельзя предположить, сколько времени оно займет (неизвестен тип <T> и его 
реализация метода Compare), следовательно переход к любой ноде от head через 
ссылки является относительно быстрой операцией и её сложность можно принять за O(1).

В качестве дополнительной оптимизации сделал вначале проверки крайних элементов, 
чтобы не продолжать поиск если значение искомого элемента заведомо не в диапазоне
значений элементов списка. Также ещё раз посмотрел на алгоритм, он удовлетворяет
условию o(log N).