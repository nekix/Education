/*
========= Урок 13 ===========

Рефлексия по уроку 11.


Задание 2*.

Используя BFS найти максимальное расстояние между двумя узлами в дереве.
В этом задании моя реализация совпала с рекомендуемой (сначала найти самый 
удаленный от текущего узел, а потом самый удаленный от найденного). 

Но в моей реализации можно было бы обобщить реализацию на два метода, 
которые бы возвращали IEnumerable<SimpleTreeNode<T>>.
Метод был бы BfsByLevel, и возвращал бы IEnumerable<SimpleTreeNode<T>> 
только одного уровня (считай фиксированного расстояния от первоначального узла).
В таком случае можно в методе GetMaxPathLength вызывать на Root узле первый 
из вышеперечисленных методов для получения самого удаленного элемента. 
После этого вызывать этот же метод уже для найденного элемента и просто 
считать число уровней - 1, которое и будет искомым расстоянием.
Это позволило бы повысить читаемость кода и сделать его пригодным для 
переиспользования в например методе для Bfs по всему дереву.


Задание 3*.

Метод, который находит все циклы в текущем (неориентированном) графе с использованием BFS.
В моей реализации я также использовал BFS. Основная сложность была с хранением 
и восстановлением текущего маршрута (когда нужно записать цикл). Для этого я 
хранил массив int[] preVertex, содержащий предыдущий узел для узла с номером 
индекса и восстанавливал путь по нему, что оказалось удачным решением.

Но можно было бы оптимизировать проверку при добавлении нового цикла в список 
на то, есть ли уже в списке такие циклы. Для этого можно было бы хранить циклы 
в множестве и высчитывать хеш для проверки на уникальность независимо от порядка 
элементов. По хешу проверка проводилась бы за O(1).

Также можно было бы не вызывать метод ClearPreVertex очищающий int[] preVertex 
за O(N) на каждой итерации основного цикла метода FindAllCycles. Вместо этого 
достаточно задать preVertex[i] = -1, а остальные значения будут перезаписываться 
на ходу по мере работы метода FindCyclesBFS.

Также возможно немного оптимизировать метод RecoverCycle, в котором сейчас два 
цикла, которые могут идти от двух узлов, на которых мы нашли текущий цикл, до 
начального узла всего обхода (а потом происходит подьем для поиска начала цикла). 
Можно сделать один цикл, который будет обходить узлы от двух узлов, на которых 
мы нашли текущий цикл, до начала цикла (для данного обхода). Это возможно если мы 
будем синхронизированно идти в цикле добавив проверку, не являются ли текущие узлы 
одинаковыми (если это окажется правдой, значит мы пришли к началу цикла и можно 
заканчивать обход). В таком случае можно будет убрать и следующий обход while 
(cycle.PeekTail() == cycle.PeekFront()), который нужен был как раз из-за того, 
что мы могли в первых двух циклах дойти до начального узла и нужно было подниматься обратно.



Рефлексия по уроку 12.


Задание 1*. Подсчитать общее число треугольников в графе.
Моя реализация в целом совпадает с рекомендуемой, за исключением нескольких 
добавленных мною оптимизаций, описанных при решении задачи. Рекомендумый подход 
с множествами для определения существования треугольника я запомню.

Только при рефлексии по 11 и 12 урокам понял, что было больше возможностей использовать 
знания из уроков по хешированию, которые были получены ранее, но эта идея не приходила 
в голову (возможно из-за того, что недостаточно развит навык комбинации изученных ранее 
подходов и новых, хотя как я чувствую динамика положительная, радует что например 
в уроке 11 задании 3 применил деку для восстановления пути и небольшой оптимизации).

Также у меня есть интуитивное ощущение, что эту задачу можно решить через математические 
операции с матрицей ребер. Как я предполагаю, сложность по времени там будет между O(N^2) и O(N^3).


Задание 2*. Поиск узлов, не входящих ни в один треугольник в графе, только через интерфейс класса (операции над графом).
Я достаточно много времени потратил, пытаясь определить способ сделать это через существующий 
интерфейс класса, но понял, что это скорее всего невозможно, поэтмоу расширил его, добавив
метод для получения всех узлов графа с помощью Dfs, и расширил метод задания 1 на возврат 
треугольников, а не просто их числа. Это совпало с рекомендуемым решением.
*/