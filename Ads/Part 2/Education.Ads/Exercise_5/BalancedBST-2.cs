using System.Collections.Generic;

namespace AlgorithmsDataStructures2
{
    // ========= Урок 5  ===========

    // Задание 1.
    // Написать метод GenerateBBSTArray, который получает
    // неотсортированный массив размера полностью заполненного
    // дерева и выдает массив структуры сбалансированного BST.

    // (Код в основном файле)

    // В ходе выполнения третьего задания я расширил реализацию,
    // чтобы она поддерживала формирование сбалансированного
    // дереве также из массива размера не полностьню заполненного дерева.
    // Закоменнтированный код исходной реализации и комментарий
    // прилагаются в методе по второй ссылке.
    // Третья ссылка (метод ComputeMiddleIndex) - описанное выше р
    // асширение реализации. Подробнее описано в третьем задании.
    // Сложность временная: O(N), где N размер массива на входе.
    // Сложность по памяти: O(N), где N размер массива на входе.


    // Задание 2.
    // Оценить, насколько поиск узла в дереве, представленном в виде массива,
    // эффективнее (или неэффективнее) поиска узла в классическом дереве с указателями.

    // Поиск узла в двоичном дереве эффективнее чем в классическом
    // с указателями. Выигрышь достигается за счёт отсутсвия обращения
    // к разным областям памяти (переход к ноде -> получение ссылки на потомка -> переход к ноде),
    // вместо этого мы работаем с одним массивом и перемещаемся только
    // в его рамках. Глобально скорость поиска также будет O(N) для
    // несбалансированного дерева и O(log N) для сбалансированного,
    // но коэффициенты около N, которые обычно опускаются,
    // будут меньше для реализации через массив. 


    // Задание 3.
    // Метод удаления узла из двоичного дерева заданного в виде массива
    // с сохранением балансировки и отсуствием пустых мест.

    // Беру массив на входе и произвожу InOrder обход, чтобы получить
    // элементы (кроме удаляемого) в отсортированном порядке за O(N).

    // Затем произвожу построение сбалансированного дерева.
    // Построение сбалансированного дерева отличается от базовой реализации
    // только более сложным выбором центрального узла. Идея в том, чтобы
    // вычислить индекс центрального узла поддерева основывается на том,
    // что у нас всегда должны быть полностью заполнены все уровни поддерева,
    // кроме самого нижнего уровня. Самый нижний уровень может быть
    // не заполнен до конца, но узлы обязательно должны располагаться слева направо.

    // В базовом методе построения дерева расширен алгоритм
    // получения индекса центрального узла. Алгоритм реализован и прокомментирован
    // по четвертой ссылке. Вычисление индекса производится за O(1).
    // Сложность временная: O(N), где N размер массива на входе.
    // Сложность по памяти: O(N), где N размер массива на входе.
    public static partial class BalancedBST
    {
        public static int[] RemoveNodeByIndex(int[] a, int nodeIndex)
        {
            if (a.Length == 0)
                return new int[0];

            int[] sorted = new int[a.Length - 1];

            // Copy in sorted order without 'nodeIndex' element
            int j = 0;
            foreach (int index in GetInorderIndexes(a, 0))
                if (index != nodeIndex)
                    sorted[j++] = a[index];

            int[] bbst = new int[a.Length - 1];

            GenerateBBSTArray(sorted, bbst, 0, 0, bbst.Length - 1);

            return bbst;
        }

        private static IEnumerable<int> GetInorderIndexes(int[] a, int index)
        {
            int left = GetLeftChildIndex(index);
            if (left < a.Length)
                foreach (int nextIndex in GetInorderIndexes(a, left))
                    yield return nextIndex;

            yield return index;

            int right = GetRightChildIndex(index);
            if (right < a.Length)
                foreach (int nextIndex in GetInorderIndexes(a, right))
                    yield return nextIndex;
        }
    }

    // Задание 4.
    // Sort B tree in O(1) time.
    // Сбалансированное дерево уже является отсортированным в определенном
    // порядке, так что его сортировка выполняется за O(1) просто возвратом дерева).
    // Нахождение максимального и минимального элемента происходит за O(1).
    // Получение элементов в отсортированном порядке происходит посредством
    // in order обхода, на сортировку время не тратится, только на обход O(N).
    // Pre order для быстрого поиска ключа за O(log N),
    // для получения листьев post order.
    // Получить узлы уровней за счёт обхода в ширину.
    // То, что дерево сбалансировано гарантирует нам,
    // что скорость поиска в нём будет стабильна. 


    // ========================================================================

    // Рефлексия по уроку 3.

    // Задание 4.
    // Метод, определяющий уровень с максимальной суммой значений узлов.
    // Использовался обход в ширину по уровню, по пути и т.д
    // и возвращающий IEnumerable. Но можно было бы сделать и версию, в
    // которую встраиваются например Action, для обработки результатов
    // обхода на разных этапах.

    // Задание 5.
    // Восстановление оригинального дерева из результатов префиксного и инфиксного обхода.
    // Мой алгоритм хоть и работает и прошел тесты, но видно что он мог быть проще
    // и эффективнее за счёт того, что для восстановления BST достаточно одного префиксного
    // обхода.
}
