/*

По ходу выполнения задания большая часть нужных полей определилась относительно прошлых заданий быстрее, что уже радует, но с некоторыми пришлом покопаться. В основном именно из-за сложности понимания способа расчёта нужного поля по имеющимся таблицам. Много строилось предположений, проверялось, время и силы кончались. По итогу выбирал в основном что-то, что предполагал ближе к началу размышлений. Не хватает контекста предметной области и контекста памяти, чтобы удерживать и прошлые уже используемые теории, и текущие. Мне кажется, если бы я с самого начала дополнял у себя где-нибудь документацию по схеме на основании того, что сам выяснил, и что увидел в эталонных решениях (именно по смыслу, особенно там где неоднозначно), то было бы проще и надежнее (умные мысли приходят поздно).

Эталонное решение шире и подробнее моего, представлена дополнительная аналитика. Учитывая её и сложность, которую она вносит в запрос (в плане предметной области, как строятся эти данные, и того, как продумать и организовать это оптимальным способом в запросе), я думаю сидел бы над таким раза в 3 дольше чем над тем, что сделал).

Учел прошлые ошибки, использовал округления, приведения типов к ::DECIMAL при делении.

CTE в моем решении скомпонованы похожим образом с эталонным решением, но немного меньше дробления (у меня нет аналога diplomatic_trade_correlation, его функции в civilization_trade_data). В этот раз CTE удобно распределились по JSON_OBJECT блокам основного запроса, получилось вынести операции сбора данных в CTE, финальный запрос по факту лишь компонует их результаты, что повысило читаемость.



total_trading_partners. В основном запросе можно было не использовать DISTINCT, т.к. в CTE civilization_trade_data уже есть GROUP BY c.civilization_type.

civilization_data
    total_caravans. Вычислено верно, но в CTE civilization_trade_data (где я вычисляю число караванов) лучше бы смотрелось название как в эталонном решении caravan_count вместо total_caravans.
    
    trade_relationship. Я использовал только два варианта значений: Favorable, Unfavorable. Но стоило добавить Balanced (=). С точки зрения предметной области было бы корректно.
    
    diplomatic_correlation. Я использовал те же данные, что и в эталонном решении, но по смыслу посчитал корреляции несколько иначе. В эталонном решении вычисляется корреляции по  diplomatic_events.relationship_change и trade_transactions.value без их преобразования. Я же вычислял по тем же данным, но diplomatic_events.relationship_change брал отрицательным или положительным в зависимости от de.outcome (Positive or Negative). Тут опять таки зависит от того, как хранятся эти данные в таблице (может они уже сразу отрицательные и положительные в diplomatic_events.relationship_change), это дополнение я сделал на базе своего предположения. Также возможно стоило бы взять trade_transactions.value в зависимости от trade_transactions.balance_direction отрицательным или положительным, но это опять таки зависит от того, какого рода корреляцию мы вычисляем.
    
    caravan_ids - эти данные я собрал сразу в CTE без отдельного запроса к таблице. 
    
critical_import_dependencies  
    dependency_score. Я посчитал иначе чем в эталонном решении. В эталонном решении вычисляется из кол-ва караванов, кол-ва товаров в караване и кол-ва цивилизаций. В своем решении я попытался построить зависимость от кол-ва товаров у караванов, редкости материалов (предположив, что caravan_goods.material_type это resouces.material_type), кол-ва мест добычи и их доступности. Т.е. пытался оценить насыщенность мира этими материалами и их редкости. Ну а если материал редкий, то скорее всего зависимость от него выше, логика была такая.
      
    import_diversity. В отличии от эталонного решения, которое считает число караванов, я считал число цивилизаций караванов с этим типом материала.
    
    resource_ids. Эти данные я собрал сразу в CTE без отдельного запрооса к таблиице.  
    
export_effectiveness  
    caravan_goods. Нужно было присоединять через LEFT JOIN (может не быть караванов с продуктом ещё).
    
    export_ratio. Моя реализация отличается от эталонной, т.к. в эталонной реализации принято, что caravan_goods.type может быть равен 'Import' или 'Export'. Я же принял что все продукты caravan_goods это экспорт, а workshop_product это произведенные.
      
    avg_markup. Опечатался, делил изначальную цену на цену в караване, а не наоборот.
    
*/