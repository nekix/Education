/*

По результатам анализ эталонного и своего решения я обнаружил обычные для себя проблемы с невнимательностью, для такого объёма задания становится тяжело держать контекст в голове, декомпозиция сильно помогает но всё равно иногда сбиваюсь. А проверка на ошибки мешает то, что глаз к концу выполнения задания уже замыливается. Тут по хорошему делать перерыв и смотреть свежим взглядом, потому что быстро и сходу не получается провести анализ такого объёма написанного.

Также я заметил, что в эталонном решении очень активно использовались таблицы, для которых у меня было в наличии только текстовое описание, но не список полей. Поэтому я не мог использовать их так, как они используются в эталонном решении. Это в целом при выполнении задания сильно его усложнило, потому что в какие-то моменты пришлось предполагать, что в них могло быть, иначе пазл совсем не клеился.

Подчерпнул для себя новое ключевое слово FILTER, обязательно включу в свой повседневный инструментарий по SQL. Рука постепенно набивается, уже проще писать такие объемные запросы и сразу их компоновать, может быть не идеальным образом, но как минимум сильно облегчающим разработку. В любом случае быстрее чем в прошлые разы определяю основную идею, какие вытащить данные, где связать таблицы и т.д.

Разбор по запросу:

total_historical_casualties. Это поле я не вычислял (его не было в примере JSON ответа). Но я заметил, что в эталонном решении используется поле 'fortress_casualties', а в моей схеме БД, которую я загрузил из первого урока, колонка просто 'casualties' из 'creature_attacks'. Видимо у меня не самая актуальная версия схемы.

threat_assessment.
    
    current_threat_level. Здесь я ошибся, нужно было вывести строковое значение уровня угрозы, а я вывел численное, да и не корректное, т.к. оценивать нужно за актуальный период. Также в эталонном решении увидел использование FILTER, до этого не использовал, изучу, выглядит как очень полезное ключевое слово.
    
    active_threats. Получил полностью из CTE creatures_stats, но не добавил в него необходимые фильтры (по активным и ограничения по актуальному периоду). По факту я взял среднюю статистику по типу созданий, а не статистику по активным. С эталонным решением у меня смысловое отличие, я не учёл, что может быть несколько территорий с созданиями одного типа, это привело к неправильным группировкам и агрегациям в CTE creatures_stats.
        
        creature_ids. В эталонном решении также фильтруется по активным созданиям, чего я не сделал, хотя название active_threats говорит о том, что это нужно.
        
        seasonal_risk_factors. Это поле я не вычислял (его не было в примере JSON ответа). В нём используется CTE seasonal_attack_patterns, в котором используются таблицы weather_records, moon_phases, которых также не было в моей схеме данных, но сама логика выглядит интересно, анализ от сезонных погодных характеристик. И проработка, особенно вычисления correlation_factors, думаю буду по работе при сложных случаях подсматривать в эталонные решения за "вдохновением")
           
    vulnerability_analysis. В отличии от эталонного решения я в CTE locations_zones_stats, в котором вычисляю все поля для этого раздела, делал группировку только по зоне и названию локации, а остальное агрегировал. Возможно это лишнее, но я перестраховался, потому что до конца не был уверен по смыслу, что l.name это zone_name (а не l.zone_type). А так большинство полей раздела я посчитал похожим образом по похожим полям, кроме тех, которые не были указаны в примере JSON ответа (я их не считал) и были связаны с таблицами, схем которых у меня не было (squad_movement, military_stations, defense_structures).
    
        vulnerability_score. В своем анализе я как в эталонном решении использовал уровни защитных сооружений, время реагирования отрядов (правда я брал его из таблицы creature_attacks, т.к. military_stations схемы таблицы у меня не было, только текстовое описание), но я не брал в учёт статистику по исходам столкновений и число патрулирующих отрядов (т.к. тоже не было схесы таблицы, только текстовое описание). В целом эталонный ответ выглядит более целостным и комплексным.
        
    defense_effectiveness. В своем решении я использовал более короткий CTE defense_types_stats и не использовал дополнительных агрегаций в основной функции при заполнении defense_effectiveness. Но с другой стороны эталонная CTE defense_structure_effectiveness используется также в разделе recommendation_summary. Мое решение не такое подробное и комплексное, поэтому была возможность сделать его короче.
        
        effectiveness_rate. Этот показатель в отличии от эталонного ответа, где считается через отношения отраженных атак, я считал через соотношение потерь при эти атаках (чем сооружение эффективнее, тем меньше потерь в битве). Мой показатель наверное более косвенный, с учётом увиденного эталонного решения я бы использовал оба, но опять таки зависит от игровых механик и как считается сражение.
        
        avg_enemy_casualties. Этот показатель я посчитал похожим на эталонный образом, но средние потери я делил на кол-во defense_structures_used, чтобы учесть и то, что зашитных структур в сражении могло участвовать несколько и приблзить эту примерную оценку к реальной (ведь в какой доле приходятся потери противника на каждую струкуру всё ещё не понятно).
        
    military_readiness_assessment. В эталонном решение CTE для этого раздела использует military_readiness таблицу, которой у меня также не было (только текстовое описание), поэтому я отталкивался от military_squad таблицы.
         
        readiness_score. Т.к. у меня не было таблицы и поля military_stations.readiness_score, я вычислял readiness_score на основе military_response_time_minutes и dwarf_skills.level.
        
        combat_effectiveness. В расчёте этого параметра я использовал соотношения потерь к потерям существ в сражениях и соотношения побед при сражениях с существами. Эталонное же решение использует соотношение побед, уровень боевых навыков, качество экипировки и сколько прошло дней с последней тренировки. Поэтому в эталонном решении получается более комплексный расчёт этого навыка.
        
        response_coverage. Здесь я усложнил с вложенным SELECT-ом, засомневался, что JSON_OBJECT вложенный в JSON_ARRAYAGG отработает без ошибок без лишнего SELECT-а.
        
    security_evolution. В эталонном решении используется таблицы fortress_events, defense_structures, military_stations, squad_movement, которых в моей схеме БД не было (кроме текстового описания). Поэтому мое решение отличается довольно сильно, а именно я все вычислял в CTE year_security_stats через одну таблицу creature_attacks).

*/