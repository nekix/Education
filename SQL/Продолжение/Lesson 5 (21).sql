-- Задача 1. Получение информации о крепости с населением

-- Приведенное в задании решение
SELECT 
    f.fortress_id,
    f.name,
    f.location,
    f.founded_year,
    JSON_OBJECT(
        'dwarf_ids', (
            SELECT JSON_ARRAYAGG(d.dwarf_id)
            FROM dwarves d
            WHERE d.fortress_id = f.fortress_id
        ),
        'resource_ids', (
            SELECT JSON_ARRAYAGG(fr.resource_id)
            FROM fortress_resources fr
            WHERE fr.fortress_id = f.fortress_id
        ),
        'workshop_ids', (
            SELECT JSON_ARRAYAGG(w.workshop_id)
            FROM workshops w
            WHERE w.fortress_id = f.fortress_id
        ),
        'squad_ids', (
            SELECT JSON_ARRAYAGG(s.squad_id)
            FROM military_squads s
            WHERE s.fortress_id = f.fortress_id
        )
    ) AS related_entities
FROM 
    fortresses f;
	
/*
Рефлексия по базе данных

Схема базы данных однозначно усложнилась.
Степень реализма поражает, на работе похожую картину увидел как пришёл, только у вас таблицы ещё задокументированы)
Наблюдается, что степень нормализации в таблицах отличается (в некоторых случается наблюдается дублирование данных), может быть это продиктовано ожидаемым использованием (много поисков с join-ми было бы иначе). Но это вносит сложность в поддержку согласованности данных
В некоторых случаях не до конца понятна логика, как например CARAVANS, DIPLOMATIC_EVENTS и civilization_type. Написано что караваны посещеют крепость, фиксируют отношения с цивилизациями. Но списка цивилизаций нет, civilization_type есть как у караваном, так и у DIPLOMATIC_EVENTS, получается что караван может устанавливать отнощения только к одной цивилизации, а в другую цивилизацию мы их уже не направим? Странно, непонятно.


Рефлексия по запросу

Основной запрос из таблицы fortresses.

Также для каждого fortresses выполняется 4 подзапроса по:
dwarves - для получения id-ов дварфов, принадлежащих крепости;
fortress_resources - для получение id-ов доступных крепости ресурсов;
workshops - для получение id-ов мастерских, принадлежащих крепости;
military_squads - для получения id-ов военных отрядов, принадлежащих крепости;

JSON_ARRAYAGG - агрегатная функция, создаст json массив из переданных в функцию значений. Если внутри null, то возвращает пустой массив.

Возможно здесь было бы оптимальнее использовать JOIN-ы, но читаемость снижается как минимум, а выгода не всегда будет, многое зависит от конкретных оптимизаций, которые применит оптимизатора запросов в конкретной СУБД конкретной версии, поэтому мне кажется данный подход предпочтительнее, пока реально не возникла потребность в оптимизации.
*/