-- Рефлексия по заданиям.

-- Задача 1*: Анализ эффективности экспедиций
/*

Различия:
1) У меня не было колонки total_members и surviving_members, т.к. их не было в описанном REST-е;
2) Не было  проверки на NULL через COALESCE для колонок survival_rate, skill_improvemen, artifacts_value, encounter_success_rate, overall_success_score, discovered_sites;
3) Не было округления для encounter_success_rate, skill_improvement, overall_success_score, artifacts_value;
4) Использовал DATEDIFF вместо EXCTRACT (DAY FROM ()) для expedition_duration;
5) Не использовал CTE (Common Table Expressions), а делал одним большим запросом;
6) Не использовал защиту от деления на NULL через COALESCE и NULLIFF.

С моей стороны было ошибкой не использовать пункты 2, 3, 5, 6. Потенциально у меня могли быть ошибки деления на null, в ответ выводились бы числа с множеством знаков после запятой, null-ы.

Интересное решение с NULLIF. Избежать деления на ноль, запомню, постараюсь закрепить на практике.

Вынос в CTE expedition_stats и skills_progression кажется мне логичным. В первом достаточно простые операции присоединения таблиц и сбора данных, которые желательно вынести отдельно, чтобы можно было эти данные дальше обработать до конечного ответа и не создавать вложенных структур. Во втором случае более сложная логика получения прогрессии, которую тоже неудобно держать вместе с основным запросом, т.к. возникают вложенные структуры и вопросы оформления агрегации этих данных.

По логике именно связей между таблицами и ограничений при этом в WHERE и ON конструкциях моя реализация совпала с эталонной, в этом ошибок не было.

Новые для меня понятия: 
1) NULLIF - сравнивает два выражения, если равны, то возвращает NULL. Если не равны, то возвращает первое выражение. ROUND(NULL, X) -> NULL;
2) EXCTRACT (DAY FROM ()) - извлекает части из переданной даты (YEAR, MONTH, QUARTER, DAY, ...);
3) CTE (Common Table Expressions) - создает временное общее табличное выражение, которое затем можно включить в SQL-запрос. Плюсы по сравнению моего и эталонного запроса очевидны: запрос разбивается на отдельные части, упрощается, легче контролировать, изменять, понимать. Изучу и отработаю на практике на паре каких-нибудь рабочих задач.

WITH .. AS (
    ...
),
.. AS (
    ...
)
...

В целом, хоть мой запрос и вероятнее всего отработает, на задание я потратил больше времени чем хотелось-бы, выбрал не самый корректный подход, упустил важные детали реализации, что говорит о том, что не хватает знаний и опыта по решению задач со сложными SQL запросами, буду нарабатывать.

*/
